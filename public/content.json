[{"title":"基于H5+的混合app","date":"2019-07-31T05:11:06.000Z","path":"2019/07/31/h5plus-app/","text":"1.技术概述基于H5+的混合app开发模式很好的将传统开发web的方式应用于开发app,是一套代码同时适用于微信内页面,web端,手机H5,甚至App,而且低技术成本的解决方案.本文记录vue cli3,h5+,Native.js相结合的方式,开发app[安卓,ios]参考文档:vue cli3.0, Vant, H5+, Native.js入门指南, Native.js示例汇总 2.要点指引(1)用vue cli3.0搭建开发web端单页面的方式,用google调试开发移动端页面(2)以上项目编译后用HBuilder打开,并右键单击转换为APP项目,此时可用mac自带模拟器打开,完善应用相关配置后,可打包应用.(3)调用原生的能力基于H5+(注意必须放在plusready事件回调中),且可进一步借助Native.js调用原生能力.(4)关于App项目IOS模拟器的调试参考调试混合app攻略,基于Safari浏览器 3.代码(1)在vue的methods方法中编写H5+移动设备代码,只能在移动设备(包括模拟器)中测试12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;van-row&gt; &lt;van-col span=&quot;8&quot;&gt; &lt;van-button type=&quot;info&quot; @click=&quot;testNative&quot;&gt;测试原生方法&lt;/van-button&gt; &lt;/van-col&gt; &lt;/van-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; testNative () &#123; try &#123; // eslint-disable-next-line if (plus.os.name === &apos;Android&apos;) &#123; // H5+ 方法:返回系统版本 // eslint-disable-next-line alert(plus.os.version) // eslint-disable-next-line &#125; else if (plus.os.name === &apos;iOS&apos;) &#123; // 调用原生IOS方法:返回设备名称 // eslint-disable-next-line let UIDevice = plus.ios.importClass(&apos;UIDevice&apos;) let currentDevice = UIDevice.currentDevice() alert(currentDevice.name()) &#125; &#125; catch (err) &#123; console.log(err.toString(), &apos;---原生语法请在对应移动设备测试&apos;) &#125; &#125; &#125;, mounted () &#123; this.testNative() &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;@import &apos;~../../style/global.less&apos;;&lt;/style&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"postMessage异步通讯","date":"2019-07-17T06:17:04.000Z","path":"2019/07/17/postMessage/","text":"1.文档目的web端异步消息传递机制,特别是对于跨域情况下的通讯,显得尤其重要,主要应用场景iframe和webview 2.实践积累iframe形式1234567891011121314151617181920212223242526272829// 父页面&lt;html&gt; &lt;body&gt; &lt;p&gt;我是父页面&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;获取子页面信息&lt;/button&gt; &lt;iframe id=&quot;mapIframe&quot; height=&quot;850px&quot; width=&quot;1500px&quot; src=&quot;http://fp1.xys.gov.cn/map/index.html#/map&quot;&gt;&lt;/iframe&gt; &lt;script&gt; // 触发事件 document.getElementById(&apos;btn&apos;).addEventListener(&apos;click&apos;, function() &#123; document.getElementById(&apos;mapIframe&apos;).contentWindow.postMessage(JSON.stringify(&#123; data: &apos;getLocation&apos; &#125;), &apos;*&apos;) &#125;) // 父页面监听事件 window.addEventListener(&apos;message&apos;,function(event) &#123; console.log(JSON.parse(event.data), &apos;--父页面监听数据&apos;) &#125;,false) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;// 子页面监听 window.addEventListener(&apos;message&apos;, function (event) &#123; if (typeof (event.data) === &apos;string&apos;) &#123; console.log(JSON.parse(event.data), &apos;--子页面接收的数据&apos;) // 向父窗口发送事件 if (window.parent &amp;&amp; window.postMessage) &#123; // let message = &#123; loadFinish: true &#125; window.parent.postMessage(JSON.stringify(&#123; data: &apos;success&apos; &#125;), &apos;*&apos;) &#125; &#125; &#125;, false) webview形式12345678910111213141516171819202122232425262728293031323334353637383940// RN项目父页面import &#123; WebView &#125; from &apos;react-native-webview&apos;&lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;WebView ref=&#123;ref =&gt; (this.webView = ref)&#125; source=&#123;webviewUrl&#125; startInLoadingState=&#123;true&#125; renderLoading=&#123;() =&gt; &lt;Loading active /&gt;&#125; javaScriptEnabled=&#123;true&#125; domStorageEnabled=&#123;true&#125; useWebKit=&#123;true&#125; automaticallyAdjustContentInsets=&#123;false&#125; onLoadEnd=&#123;this.onLoadEnd&#125; onLoadStart=&#123;this.onLoadStart&#125; obLoadEnd=&#123;this.onLoadEnd&#125; onError=&#123;this.onLoadError&#125; onMessage=&#123;this.onMessage&#125; /&gt; &lt;/View&gt; onLoadEnd = () =&gt; &#123; this.webView.postMessage(JSON.stringify(&#123;data:&apos;hi&apos;&#125;)) &#125; onMessage = event =&gt; &#123; try &#123; let &#123; loadFinish &#125; = JSON.parse(event.nativeEvent.data) &#125; catch (error) &#123;&#125; &#125;// web端子页面window.onload = () =&gt; &#123; document.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123; const msg = JSON.parse(data); &#125;) // 消息回传给rn端 if (window.postMessage) &#123; let message = &#123; loadFinish: true &#125;; window.postMessage(JSON.stringify(message)); &#125;&#125;","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"TypeScript和vue的完美整合","date":"2019-07-13T08:03:54.000Z","path":"2019/07/13/ts-vue/","text":"1.文档目的新技术架构的实践笔记参考：typescript教程,vue-class-component,vue-property-decorator,vue-property-decorator使用指南 ,typescript与vue的结合 2.细节梳理2.1重新认知文件后缀.html文件中可以直接写代码，然后用浏览器打开.js文件可以用命令行中node test.js运行.ts是js类型的超级，添加了类型检测等特性。可以在命令行中全局安装typescript，并编译tsc test.tsjsx是一种嵌入式语法，可被转换成合法的JavaScript.tsx是可支持jsx语法的ts文件总结：ts,jsx，以及tsx都可转换为js 2.2认识vue-class-component和vue-property-decorator为了适应typescript引入vue带来的变化，特意发展了这两个库对vue语法进一步做了包装，这就是两个语法糖。vue-class-component定义了基本以class形式的书写方式，vue-property-decorator在前者基础上定义了更多的声明式语法糖","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"util工具方法","date":"2019-07-08T06:09:03.000Z","path":"2019/07/08/util/","text":"1.文档目的收集整理常用实现,积累总结经验 2.实践积累2.1对象结构循环123456789// JS形式for(let key in obj)&#123; console.log(key); console.log(obj[key]);&#125;// JSX形式&#123;Object.keys(obj).map((key, index) =&gt; ( &lt;ListItem key=&#123;`obj$&#123;index&#125;`&#125; text=&#123;key&#125; extra=&#123;obj[key]&#125;/&gt;))&#125; 2.2模拟数据与接口数据转换[装饰者模式应用]123456// 写在具体逻辑模块中transData(data)&#123; let &#123;userName1: name, userAge1: age&#125; = data let oInfo = &#123;name, age&#125; return oInfo&#125; 2.3动态创建数组1234// 简单数组[1,2,3]// 复杂重复数组new Array(8).fill(&#123;name: &apos;xiaoming&apos;, age: 12&#125;)","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"react概述","date":"2019-06-30T00:53:51.000Z","path":"2019/06/30/react/","text":"1.文档目的仔细阅读了React官方教程，对易疏忽的地方做个笔记，便于知识的整体梳理和消化参考网址：React逐步学习指南,React实践教程 2.文档内容2.1整体认知React 是一个用于构建用户界面的 JavaScript 库，以组件为最小单元，以JSX为语法基础，以单向（自上而下）数据流props维护组件关系以私有state控制组件渲染和数据更新 2.2安装或引入React推荐的工具链方式：Create React Appscript标记引入：1234567&lt;!-- 加载 React。--&gt; &lt;!-- 注意: 部署时，将 &quot;development.js&quot; 替换为 &quot;production.min.js&quot;。--&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt; &lt;!-- 加载我们的 React 组件。--&gt; &lt;script src=&quot;like_button.js&quot;&gt;&lt;/script&gt; 2.2组件的实现方式组件有函数实现方式和class实现方式两种。函数组件基本结构（无受控state）：123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; class组件基本结构(可以有受控state)123456789class Welcome extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;info: null&#125;; &#125; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;, &#123;this.state.info&#125;&lt;/h1&gt;; &#125;&#125; 2.3JSX语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Welcome extends React.Component &#123; constructor(props) &#123; super(props); // 私有变量且受控 this.state = &#123;isShow: null, listData: null&#125;; // 私有变量且非受控 this.title = null &#125; // 函数用表达式形式的箭头函数，保证了this引用的正确，若非如此，则需要在constructor中显示bind(this) _renderNode = () =&gt; &#123; // JSX作为表达式当然可以使其等于一个变量 const nodeElement = &lt;Text&gt;Hello&lt;/Text&gt; return ( &lt;View&gt; // JSX中&#123;&#125;中可以是任何表达式，包括变量 &lt;Text&gt;问候语：&#123;nodeElement&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125; _renderList = () =&gt; &#123; let &#123;listData&#125; = this.state return ( &lt;View&gt; // JSX中循环结构可直接用map表达式，注意绑定key(尽量不直接用index) &#123;listData.map(item =&gt;(&lt;View key=&#123;item.id&#125;&gt; &lt;Text&gt;&#123;item.name&#125;&lt;/Text&gt; &lt;/View&gt;))&#125; &lt;/View&gt; ) &#125; render() &#123; // 公有入参属性 let &#123;id&#125; = this.props let &#123;isShow, listData&#125; = this.state // JSX表达式可以作为函数的返回值(同样可以作为函数入参等任何变量/表达式可以在的地方) return ( &lt;View&gt; // JSX中&#123;&#125;中可以是任何表达式，包括函数 &#123;this._renderNode()&#125; // 一个表达式，只能是一个整体，不能是多个语句 // 选择结构，在JSX中直接用三元表达式 &#123;isShow ? &lt;View&gt;&lt;Text&gt;是&lt;/Text&gt;&lt;/View&gt; : &lt;View&gt;&lt;Text&gt;否&lt;/Text&gt;&lt;/View&gt;&#125; // 布尔结构，在JSX中直接用&amp;&amp;运算符 &#123;listData &amp;&amp; this._renderList()&#125; &lt;/View&gt; ) &#125;&#125; 总结：1.JSX本身是个表达式，可以赋值给一个变量。即变量可以在的位置JSX表达式也可以。2.JSX中可以用{}处理表达式(表达式的形式可以是一个变量，&amp;&amp;运算符，三元运算符，map()运算符，函数等形式) 2.4其他要点1.props和state都可以由生命周期控制2.受控表单统一用value和onChange处理,多个表单项共用处理函数需要提供不同name值，且受控表单便于在处理函数中做校验123456789101112&lt;input type=&quot;text&quot; name=&quot;name1&quot; value=&#123;this.state.value1&#125; onChange=&#123;this.handleChange&#125; /&gt;&lt;input type=&quot;text&quot; name=&quot;name2&quot; value=&#123;this.state.value2&#125; onChange=&#123;this.handleChange&#125; /&gt; handleChange(event) &#123; const target = event.target; const value = target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; 若是同一个对象不同属性的绑定，则只需要设置setState中不同属性即可12&lt;input type=&quot;text&quot; value=&#123;this.state.oInfo.value1&#125; onChange=&#123;value1 =&gt; this.setState(&#123;oInfo: &#123;...oInfo, value1&#125;&#125;)&#125; /&gt;&lt;input type=&quot;text&quot; value=&#123;this.state.oInfo.value2&#125; onChange=&#123;value2 =&gt; this.setState(&#123;oInfo: &#123;...oInfo, value2&#125;&#125;)&#125; /&gt; 3.基于React构建页面的步骤：第一步：将设计好的 UI 划分为组件层级第二步：用 React 创建一个静态版本(仅用props)第三步：确定 UI state 的最小（且完整）表示第四步：确定 state 放置的位置（若多个组件共用state，则放置在它们最近的共同组件中）第五步：添加反向数据流等其他数据逻辑","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"基于React Native的android原生代码实现","date":"2019-06-29T23:55:15.000Z","path":"2019/06/30/native/","text":"1.文档目的React Native可以在其基础上直接调用原生代码，本文仅举一个简单的例子，更多内容需要多多实践参考网址：RN中Android原生模块 2.实例实践2.1原生组件展示假设我们希望可以从 RN 调用原生代码实现的一个 Toast 消息{ToastExample.show(‘Awesome’, ToastExample.SHORT);}，代码如下：创建android/app/src/main/java/com/{your-app-name}/ToastModule.java123456789101112131415161718192021222324252627282930313233343536373839404142package com.&#123;your-app-name&#125;;import android.widget.Toast;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReactContext;import com.facebook.react.bridge.ReactContextBaseJavaModule;import com.facebook.react.bridge.ReactMethod;import java.util.Map;import java.util.HashMap;// 要求继承ReactContextBaseJavaModulepublic class ToastModule extends ReactContextBaseJavaModule &#123; private static final String DURATION_SHORT_KEY = &quot;SHORT&quot;; private static final String DURATION_LONG_KEY = &quot;LONG&quot;; public ToastModule(ReactApplicationContext reactContext) &#123; super(reactContext); &#125; // ReactContextBaseJavaModule要求派生类实现getName方法,假如该方法返回‘ToastExample’，则RN通过NativeModules.ToastExample访问该模块 @Override public String getName() &#123; return &quot;ToastExample&quot;; &#125; // getContants返回一些可以被RN同步访问的预定于的常量 @Override public Map&lt;String, Object&gt; getConstants() &#123; final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;(); constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT); constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG); return constants; &#125; // RN访问java是异步的，只能通过回调或监听，这里返回必须使用@ReactMethod注解 @ReactMethod public void show(String message, int duration) &#123; Toast.makeText(getReactApplicationContext(), message, duration).show(); &#125;&#125; 注册模块，创建android/app/src/main/java/com/{your-app-name}/CustomToastPackage.java 1234567891011121314151617181920212223242526package com.&#123;your-app-name&#125;;import com.facebook.react.ReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.uimanager.ViewManager;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class CustomToastPackage implements ReactPackage &#123; @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) &#123; return Collections.emptyList(); &#125; @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) &#123; List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;(); modules.add(new ToastModule(reactContext)); return modules; &#125;&#125; 这个模块需要在MainApplication.java文件的getPackages方法中暴露给RN,具体路径是android/app/src/main/java/com/your-app-name/MainApplication.java 123456789 // MainApplication.java...import com.your-app-name.CustomToastPackage; // &lt;-- 引入你自己的包...protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CustomToastPackage()); // &lt;-- 添加这一行，类名替换成你的Package类的名字.&#125; 在RN端使用的代码,建议将原生模块提供的模块都统一管理 12345import &#123; NativeModules &#125; from &quot;react-native&quot;;let &#123;ToastExample&#125; = NativeModulesexport &#123;ToastExample&#125;; 2.2回调返回计算值回调函数模式提供一个函数来把返回值传回给 JavaScript在JAVA端定义函数如下：12345678910111213141516171819202122232425import com.facebook.react.bridge.Callback;public class UIManagerModule extends ReactContextBaseJavaModule &#123;... @ReactMethod public void measureLayout( int tag, int ancestorTag, Callback errorCallback, Callback successCallback) &#123; try &#123; measureLayout(tag, ancestorTag, mMeasureBuffer); float relativeX = PixelUtil.toDIPFromPixel(mMeasureBuffer[0]); float relativeY = PixelUtil.toDIPFromPixel(mMeasureBuffer[1]); float width = PixelUtil.toDIPFromPixel(mMeasureBuffer[2]); float height = PixelUtil.toDIPFromPixel(mMeasureBuffer[3]); successCallback.invoke(relativeX, relativeY, width, height); &#125; catch (IllegalViewOperationException e) &#123; errorCallback.invoke(e.getMessage()); &#125; &#125;... 在RN端调用如下：12345678910UIManager.measureLayout( 100, 100, msg =&gt; &#123; console.log(msg); &#125;, (x, y, width, height) =&gt; &#123; console.log(x + &quot;:&quot; + y + &quot;:&quot; + width + &quot;:&quot; + height); &#125;); 还有监听模式，Promises模式等更多功能实践，请参考官网…","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"设计模式解读","date":"2019-06-15T07:35:34.000Z","path":"2019/06/15/design/","text":"1.文档目的系统记录常见设计模式的js代码实现，加深理解设计模式的魅力。设计模式的意义在于:最佳实践提高代码重用，易于理解和维护参考网址：w3c设计模式 2.设计模式2.1设计原则单一职责原则SRP: 属性及其相关操作最少知道原则：一个实体应当尽量少地与其他实体之间发生相互作用，强调降低耦合接口隔离原则：使用多个隔离的接口，比使用单个接口要好，强调降低耦合开闭原则：对扩展开放，对修改关闭里氏代换原则：任何基类可以出现的地方，子类一定可以出现依赖倒转原则：依赖于抽象而不依赖于具体合成复用原则：尽量组合，而非继承 2.2设计模式分类创建型模式(隐藏创建逻辑)：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式结构型模式(组合继承获得新功能)：适配器模式、桥接模式、过滤器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式行为型模式(对象通信)：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、空对象模式、策略模式、模板模式、访问者模式 2.3设计模式一览构造函数模式：模拟类，用于创建特定类型（类）的对象原型模式：通过拷贝原型创建新对象，比如js里的prototype单例模式：在某空间提供唯一的访问点，保证一个类只有一个实例工厂模式：定义一个用于创建对象的接口，由子类决定实例化哪个类（厂长负责实施子类发出的任务）桥接模式: 若不希望两个层次之间耦合，桥接模式可以使它们建立一个关联关系代理模式：为其他对象提供一种代理以控制对这个对象的访问（eg：大叔代替小明送给女孩儿鲜花）建造者模式：使同样的构建过程（eg:回调机制）可以创建不同的表示（由参数决定），而不用关注细节（回调的实现原理）命令模式：用于将一个请求方法封装成一个对象（参数不同，命令不同）观察者模式：发布订阅模式适配器模式：将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（比如：电脑充电器）职责链模式：使多个对象都有机会处理请求迭代器模式：为遍历不同的集合结构提供一个统一的接口外观模式：为一组接口提供一个高层接口，使得接口更容易使用策略模式：算法的相互替换不会影响到使用算法的客户中介者模式：比如多架飞机的通讯都是通过中控系统进行模板方法：定义操作的算法的骨架（抽象类），而将步骤实现延迟到子类中（子类重写父类方法）装饰者模式：包装同接口的对象，通过重载方法的形式添加新功能（调用原始对象方法并扩展）组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。（eg:Dom都有增删改子节点的通用功能）模板方法:定义一个操作中的算法的骨架，而将一些步骤延迟到子类重写 2.4易混淆设计模式概念对比适配器则意味着改变一个已有对象的接口。代理模式在不改变原有接口的条件下，用另一个对象定义了一个代理装饰者模式增强了其它对象的功能而同时又不改变它的接口桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。 2.5项目中实战分析举例(1)工厂模式：switch逻辑外部定义一个统一的接口，通过参数决定具体执行路线，比如Redux中action的调用(2)观察者模式:比如点击事件就是一种最常见的发布订阅模式addEventListener，再比如vue中的data和rn中的state,对其改变时，依赖它的对象都将得到通知和更新(3)策略模式：比如表单校验中针对不同的表单类型进行不同的校验实现 3.实例研读3.1构造函数模式构造函数模式：用于创建特定类型（类）的对象[可接收参数以便第一次创建对象时设置成员值]1234567891011// 注：这里将属性和方法都写在构造函数中，那么每个新的实例都会不同，若需共享，应绑定至prototypefunction Animal(name) &#123; this.name = name;&#125;//注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype//主要是用来避免重写定义原型prototype对象Animal.prototype.getName= function () &#123; return &apos;该动物的名称&apos; + this.name&#125;;var animal = new Animal(&quot;老虎&quot;);console.log(animal.getName()); 3.2原型模式通过拷贝原型创建新对象[在上面构造函数的基础上利用原型模式实现继承]12345678function Cat()&#123;&#125;// 拷贝继承Cat.prototype = Animal.prototype;// 恢复constructorCat.prototype.constructor = Cat;// 实例化var cat = new Cat(&quot;花小猫&quot;);console.log(cat.getName()) // 花小猫 3.3单例模式单例模式：保证一个类只有一个实例实现的方法是先判断实例是否存在，若存在则直接返回，否则再创建用途：单例作为命名空间提供者，保证在某空间中提供一个唯一的访问点1234567891011121314151617181920212223242526272829var SingletonTester = (function () &#123; //参数：传递给单例的一个参数集合 function Singleton(args) &#123; //设置args变量为接收的参数或者为空（如果没有提供的话） var args = args || &#123;&#125;; //设置name参数 this.name = &apos;SingletonTester&apos;; //设置pointX的值 this.pointX = args.pointX || 6; //从接收的参数里获取，或者设置为默认值 //设置pointY的值 this.pointY = args.pointY || 10; &#125; //实例容器 var instance; var _static = &#123; name: &apos;SingletonTester&apos;, //获取实例的方法 //返回Singleton的实例 getInstance: function (args) &#123; if (instance === undefined) &#123; instance = new Singleton(args); &#125; return instance; &#125; &#125;; return _static;&#125;)();var singletonTest = SingletonTester.getInstance(&#123; pointX: 5 &#125;);console.log(singletonTest.pointX); // 输出 5 3.3工厂模式工厂模式定义了一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。工程模式应该有厂长，负责调度实施子类发出的任务eg:switch动态匹配就是该模式1234567891011121314151617181920212223242526// 对象方式var productManager = &#123;&#125;;productManager.createProductA = function () &#123; console.log(&apos;ProductA&apos;);&#125;productManager.createProductB = function () &#123; console.log(&apos;ProductB&apos;);&#125;productManager.factory = function (typeType) &#123; return new productManager[typeType];&#125;productManager.factory(&quot;createProductA&quot;);// 方法方式function switchFun(type)&#123; switch(type)&#123; case &apos;ProductA&apos;: console.log(&apos;ProductA&apos;) break case &apos;ProductB&apos;: console.log(&apos;ProductB&apos;) break default: console.log(&apos;nothing&apos;) &#125;&#125;switchFun(&quot;ProductA&quot;); 3.4桥接模式若不希望两个层次之间耦合，桥接模式可以使它们建立一个关联关系。123456789101112131415161718// 事件绑定与处理事件的方法定义&lt;script&gt; // 抽象代码不可直接运行 function getBeerById(id, callback) &#123; asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123; callback(resp.responseText) &#125;) &#125; // getBeerByIdBridge桥接原理:将addEvent直接调用getBeerById的定义分离 // addEvent只是调用了一个桥,桥只是&apos;调用了getBeerById&apos;,而getBeerById的定义则被抽离 // 优点:使得处理事件的方法实现得以分离,则该方法方便被重用,而且getBeerByIdBridge也方便调用其他处理事件的方法 addEvent(element, &apos;click&apos;, getBeerByIdBridge) function getBeerByIdBridge(e) &#123; getBeerById(this.id, function(res) &#123; console.log(&apos;Requested:&apos; + res) &#125;) &#125;&lt;/script&gt; 3.5外观模式如果需要调用一组接口实现一个更大的功能,那么就把这些方法放在一起组成一个新的方法,从而简化调用eg:阻止事件默认行为1234function handleClick(e) &#123; e.preventDefault(); e.stopPropagation();&#125; 3.6模板方法定义一个操作中的算法的骨架，而将一些步骤延迟到子类重写12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; // 抽象步骤 var MakeDrink = function() &#123;&#125; MakeDrink.prototype.step = function() &#123; this.boilWater() this.addDrink() this.cover() &#125; MakeDrink.prototype.boilWater = function() &#123; console.log(&apos;将水烧开!&apos;) &#125; MakeDrink.prototype.addDrink = function() &#123; throw new Error(&apos;该方法必须重写!&apos;) &#125; MakeDrink.prototype.cover = function() &#123; console.log(&apos;盖上盖子!&apos;) &#125; // 冲咖啡 var Coffee = function() &#123; MakeDrink.apply(this) &#125; Coffee.prototype = new MakeDrink() Coffee.prototype.addDrink = function() &#123; console.log(&apos;添加咖啡!&apos;) &#125; //冲茶叶 var Tea = function() &#123; MakeDrink.apply(this) &#125; Tea.prototype = new MakeDrink() Tea.prototype.addDrink = function() &#123; console.log(&apos;添加茶叶!&apos;) &#125; // 验证调用 var coffee1 = new Coffee() coffee1.step() console.log(&apos;--------分割线----------&apos;) var tea1 = new Tea() tea1.step() &lt;/script&gt; 3.7策略模式校验表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;script&gt; // 策略处理类 let validator = &#123; types: &#123;&#125;, // 验证规则处理类,后面会扩展各种规则的定义 config: &#123;&#125;, // 定义需要使用的验证类型 messages: [], // 验证所对应的错误消息集合 validate: function(data) &#123; // 暴露的公开验证方法,参数类型为obj,data是原始数据 let msg, type, validateTypeFun, result_ok this.messages = [] // 清空所有的错误信息 for (let key in data) &#123; if (data.hasOwnProperty(key)) &#123; //原始数据中是否包含可枚举的字段key type = this.config[key] // 用户为字段key配置的验证规则是什么?比如isNonEmpty validateTypeFun = this.types[type] // 获取验证规则对应的验证方法是否已定义 if (!type) &#123; continue // 如果针对key的验证规则未配置，则不处理 &#125; if (!validateTypeFun) &#123; // 如果验证方法为定义，抛出异常 throw &#123; name: &apos;ValidationError&apos;, message: &apos;该类型无对应处理方法:&apos; + type &#125; &#125; result_ok = validateTypeFun.validate(data[key]) //正常验证 if (!result_ok) &#123; msg = &apos;非法值&apos; + key + &apos;, &apos; + validateTypeFun.instructions this.messages.push(msg) &#125; &#125; &#125; return this.hasErrors() &#125;, // helper hasErrors: function() &#123; return this.messages.length !== 0 &#125; &#125; // 验证给定的值是否不为空 validator.types.isNotEmpty = &#123; validate: function(value) &#123; return value !== &apos;&apos; &#125;, instructions: &apos;传入的值不能为空&apos; &#125; // 验证给定的值是否是数字 validator.types.isNumber = &#123; validate: function(value) &#123; return !isNaN(value) &#125;, instructions: &apos;传入的值只能是合法的数字，例如：1, 3.14 or 2010&apos; &#125; // 定义需要验证的数据集合和需要验证的规则类型 var data = &#123; first_name: &apos;&apos;, age: &apos;unknown&apos; &#125; validator.config = &#123; first_name: &apos;isNotEmpty&apos;, age: &apos;isNumber&apos; &#125; // 测试获取验证结果 validator.validate(data) if (validator.hasErrors()) &#123; console.log(validator.messages.join(&apos;\\n&apos;)) &#125;&lt;/script&gt; 3.8适配器模式鸭子和狗都有行走(fly,run)和叫声(sound)行为12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;script&gt; // 抽象行为 var Duck = function() &#123;&#125; Duck.prototype.fly = function() &#123; throw new Error(&apos;该方法必须被重写!&apos;) &#125; var Dog = function() &#123;&#125; Dog.prototype.run = function() &#123; throw new Error(&apos; 该方法必须被重写!&apos;) &#125; // 定义构造函数 var DuckObj = function() &#123; Duck.apply(this) &#125; DuckObj.prototype = new Duck() DuckObj.prototype.fly = function() &#123; console.log(&apos;鸭子可以飞起来!&apos;) &#125; var DogObj = function() &#123; Dog.apply(this) &#125; DogObj.prototype = new Dog() DogObj.prototype.run = function() &#123; console.log(&apos;狗可以跑的很快!&apos;) &#125; // 鸭子适配器:使得鸭子可以支持狗的run方法,同时使其自身飞的快5倍 var DuckAdapter = function(oDuck) &#123; Duck.apply(this) this.oDuck = oDuck &#125; DuckAdapter.prototype = new Duck() DuckAdapter.prototype.run = function() &#123; // 虽然方法名字是dog的run,但是内部实现可以任意,只是为了适配 this.oDuck.fly() &#125; // 重新定义fly实现,相当于对fly进行了重写 DuckAdapter.prototype.fly = function() &#123; var nFly = 0 var nLenFly = 3 for (; nFly &lt; nLenFly; ) &#123; this.oDuck.fly() nFly = nFly + 1 &#125; &#125; // 测试 var oDuck = new DuckObj() var oDug = new DogObj() var oDuckAdapter = new DuckAdapter(oDuck) console.log(&apos;---------原有的鸭子行为-------&apos;) oDuck.fly() console.log(&apos;---------原有的狗行为-------&apos;) oDug.run() console.log(&apos;---------适配器鸭子的行为（鸭子调用狗的方法名称）-------&apos;) oDuckAdapter.run() console.log(&apos;---------适配器鸭子的行为（鸭子原有fly行为被重写,调用了3遍）-------&apos;) oDuckAdapter.fly()&lt;/script&gt; 3.9代理模式大叔代理小明送给美女鲜花123456789101112131415161718192021&lt;script&gt; var Girl = function(name) &#123; this.name = name &#125; var Xiaoming = function(girl) &#123; this.girl = girl this.sendFlower = function(flower) &#123; console.log(&apos;Hi &apos; + girl.name + &apos;, xiaoming送你一个礼物：&apos; + flower) &#125; &#125; // 大叔代理 var ProxyMan = function(girl) &#123; this.girl = girl this.sendFlower = function(flower) &#123; new Xiaoming(girl).sendFlower(flower) //代替小明送花咯 &#125; &#125; // 测试 var proxyMan = new ProxyMan(new Girl(&apos;酸奶小妹&apos;)) proxyMan.sendFlower(&apos;999朵玫瑰&apos;)&lt;/script&gt; 3.10装饰者模式比继承更有弹性的替代方案,通过重载方法的形式扩展功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!-- 实例1:重写原方法 --&gt;&lt;script&gt; function Macbook() &#123; this.cost = function() &#123; return 1000 &#125; &#125; function Memory(macbook) &#123; this.cost = function() &#123; return macbook.cost() + 75 &#125; &#125; // var myMacbook = new Memory(new Macbook()) console.log(myMacbook.cost())&lt;/script&gt;&lt;!-- 实例二:重写原方法的一部分(有调用点的方法调用) --&gt;&lt;script&gt; // 被装饰者 function ConcreteClass() &#123; this.performTask = function() &#123; this.preTask() console.log(&apos;doing something&apos;) this.postTask() &#125; this.preTask = function() &#123; console.log(&apos;原有执行之前...&apos;) &#125; this.postTask = function() &#123; console.log(&apos;原有执行之后...&apos;) &#125; &#125; // 抽象装饰 function AbstractDecorator(decorated) &#123; this.performTask = function() &#123; decorated.performTask() &#125; &#125; // 定义具体装饰:重写preTask和postTask function ConcreteDecoratorClass(decorated) &#123; this.base = AbstractDecorator this.base(decorated) decorated.preTask = function() &#123; console.log(&apos;装饰执行之前...&apos;) &#125; decorated.postTask = function() &#123; console.log(&apos;装饰执行之后...&apos;) &#125; &#125; // 测试 var decorator1 = new ConcreteDecoratorClass(new ConcreteClass()) decorator1.performTask()&lt;/script&gt;&lt;!-- 实例三:重写原方法的一部分(无调用点) --&gt;&lt;script&gt; var tree = &#123;&#125; tree.decorate = function() &#123; console.log(&apos;树木初始化...&apos;) &#125; // 添加装饰器定义 tree.addDecorator = function(deco) &#123; tree[deco].prototype = this return new tree[deco]() &#125; tree.Leaves = function() &#123; this.decorate = function() &#123; this.Leaves.prototype.decorate() console.log(&apos;添加一些树叶...&apos;) &#125; &#125; tree.Flower = function() &#123; this.decorate = function() &#123; this.Flower.prototype.decorate() console.log(&apos;添加一些花朵...&apos;) &#125; &#125; // 测试 tree = tree.addDecorator(&apos;Leaves&apos;) tree = tree.addDecorator(&apos;Flower&apos;) tree.decorate() //执行Flower的decorate方法,并依次向上递归调用&lt;/script&gt; 3.11组合模式菜单和菜单项都有类似的公共行为:“整体-部分”的层次结构,用户对单个对象和组合对象的使用具有一致性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; // 抽象类 var MenuComponent = function() &#123;&#125; MenuComponent.prototype.getName = function() &#123; throw new Error(&apos;该方法必须重写!&apos;) &#125; MenuComponent.prototype.print = function() &#123; throw new Error(&apos;该方法必须重写!&apos;) &#125; MenuComponent.prototype.add = function() &#123; throw new Error(&apos;该方法必须重写!&apos;) &#125; // 菜单 var Menu = function(sName) &#123; MenuComponent.apply(this) this.aMenuComponents = [] this.sName = sName &#125; Menu.prototype = new MenuComponent() Menu.prototype.getName = function() &#123; return this.sName &#125; Menu.prototype.print = function() &#123; console.log(&apos;-----菜单名称:&apos; + this.getName()) this.aMenuComponents.forEach(function(item) &#123; item.print() &#125;) &#125; Menu.prototype.add = function(oMenuComponent) &#123; this.aMenuComponents.push(oMenuComponent) &#125; // 菜单项 var MenuItem = function(sName) &#123; MenuComponent.apply(this) this.sName = sName &#125; MenuItem.prototype = new MenuComponent() MenuItem.prototype.getName = function() &#123; return this.sName &#125; MenuItem.prototype.print = function() &#123; console.log(&apos;-----菜单项名称:&apos; + this.getName()) &#125; // 调用测试 var menu1 = new Menu(&apos;菜单一&apos;) menu1.add(new MenuItem(&apos;菜单项一&apos;)) menu1.add(new MenuItem(&apos;菜单项二&apos;)) menu1.print()&lt;/script&gt;","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"prototype原型链与构造函数法模拟类","date":"2019-06-15T04:06:28.000Z","path":"2019/06/15/prototype/","text":"1.概念原型链：如果在第一个对象上没有找到需要的属性或方法，引擎就会继续在prototype关联的对象上继续查找。 2.理论探究 图（1）1.在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数(简单理解为“父类”)的原型prototype，这也保证了实例能够访问在构造函数原型(简单理解为“父类”)中定义的属性和方法。2.方法(Function)这个特殊的对象，除了和其他对象一样有上述proto属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象prototype）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。小结：对象有属性proto,指向该对象的构造函数(简单理解为“父类”)的原型对象prototype。方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象(所有实例共享的属性和方法)3.模拟类：首先要明确面向对象语言中，对象实例化和继承都是通过“复制”实现的，即各个实例之间没有关联关系。但是js中（var a= new Foo()）new[带new的函数调用被称为“构造函数调用”]一个新对象实际发生的却是将新对象a的proto属性指向Foo.prototype（同时：a.constructor === Foo === Foo.prototype.constructor）,即各个实例共享了属性和方法，相互之间建立了关联关系。4.模拟继承（也叫“原型继承”）：实质是创建两个对象（父子）之间的关联关系，使得一个对象（子）可以通过委托访问另一个对象（父）的属性和函数，核心是apply()方法的应用小结：对象有属性constructor,指向的是对象关联的函数（Foo父类）[实质上是a.constructor === Foo.prototype.constructor]new实例化的实质：”构造函数”会被调用，而绑定在prototype属性上的公共属性和方法会和实例的proto属性建立关联关系 实例：构造函数法模拟继承分析12345678910111213141516171819202122// 父类 function Animal(species)&#123; //实例化对象的过程中会通过new调用该“构造函数”执行，即初始化 //即：每个实例都会产生属于自己的species属性 this.species = species; &#125; // 子类:注意将父类需要的属性放前面，方便arguments正确对应 function Cat(species,name)&#123; Animal.apply(this, arguments); //通过apply方法将父类绑定到自身环境 this.name = name; &#125;// 公共的不变的属性和方法直接绑定至prototype // 即：prototype不属于构造函数，不会在new是被调用，而会被各个实例所共享 Cat.prototype.sound = &quot;喵喵喵...&quot;; Cat.prototype.eat = function()&#123;console.log(&apos;猫爱吃鱼&apos;)&#125;; //new调用实质：cat1.constructor = Cat.prototype.constructor，则产生不同的species实例变量 //同时：cat1._proto_ = Cat.prototype,保证了所有实例可以调用共享的绑定在prototype上的属性和方法 var cat1 = new Cat(&quot;动物&quot;,&quot;大毛&quot;); //调用 console.log(cat1.species, &apos;---我是继承父类的属性&apos;) console.log(cat1.sound, &apos;---我是绑定在子类prototype上的公用属性&apos;)","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"this和function","date":"2019-06-14T08:00:41.000Z","path":"2019/06/14/this/","text":"1.文档目的通过简单的实例分析this和function深层原理，便于对js加深理解参考：this用法，this原理,bind,apply,call动态改变this指向 2.剖析2.1this的定义this就是函数运行时所在的环境对象,强调“函数”内部，“运行”环境 2.2明确几点前提条件（1）首先需要明确的常识undefined是一个类型，也是一个值。而is not defined是报错（2）全局变量的声明定义会被提升至顶端，而函数作用域的变量会被提升至函数顶部，js只有函数作用域，没有块作用域，但是let实现了块作用域，且不会对其进行提升。const同理，但其不可修改。function fun(){}和var变量一样，声明定义会被提升。但是fun=function (){}却不会被提升（3）函数是在运行时编译[通常就在运行前的几微妙]的,函数未运行就不存在函数内部编译，更不存在内部报错.最外层会直接运行，不妨也将window环境视为一个全局函数体（4）不成功的右查询RHS引用会导致抛出ReferenceError异常[非严格模式：不成功的左查询LHS会创建一个全局的变量]。ReferenceError同作用域判别相关，而TypeError则代表作用域判别成够了，但是对结果的操作是非法或不合理的。 2.3实例解析思考题1：1234567891011//分析该函数行为，必须要等到运行时才有意义//当运行时，function fun()&#123; //对x进行RHS,完全找不到[注：LHS才会重新定义变量并绑定到window上]，即没有定义过x变量本身[注：区别于x的value值] //故报红：Uncaught ReferenceError: x is not defined console.log(x) //this.x可以编译为window.x[即window是存在的，其上并没有x,故window.x的value值为‘undefined’(未定义的变量，或变量值为undefined)] console.log(this.x)&#125;fun() //运行时 总结：复合变量的value值为undefined是指主变量存在，附变量未定义。而is not defined是指整个变量本身就不存在。思考题2：12345678910111213141516var obj = &#123; //obj的value是个对象的指针地址 //obj.foo的value是个function的指针地址 //函数内部只有this.bar,由于未在运行时，故this.bar暂不分析 foo: function () &#123; console.log(this.bar) &#125;, bar: 1 //obj.bar的value是数值1&#125;;var foo = obj.foo; //将obj.foo的value值[function的指针地址]赋值给window.foo的value值，即变量window.foo的value也是地址var bar = 2; //window.bar的value是数值2//小括号代表执行，即执行obj.foo的value,此时obj.foo的value是function的指针地址，即执行function本身。//由于函数是由obj调用,而obj中存在obj.bar的value为1，故执行结果为1obj.foo()//小括号代表执行，即执行window.foo的value,此时window.foo的value也是function的指针地址，即执行function本身。//由于函数是由window调用，而window中存在window.bar的value为2，故执行结果为2foo() 2.4显示绑定thisbind、apply 、 call 三者都是用来改变函数的this对象的指向的bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 ，但两者接受参数的方式不同。func.bind(this)()func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]) 2.5箭头函数中的this箭头函数的this总是指向定义时所在的对象，而不是使用时所在的对象。即this对象的指向是固定的12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"js模拟class","date":"2019-06-12T05:33:13.000Z","path":"2019/06/12/class/","text":"1.文档目的类：数据及其行为的封装，可视为一种“类型”对象：对象是类的实例。js中一切皆对象，没有类的概念，但可以通过对象来模拟类实例：相对“类”来说，对象的另一种称谓，故常说“对象实例”，其实指同一事物构造函数：类的一个特殊方法，用于在创建对象时初始化实例[通常会初始化实例属性]参考网址: JS面向对象编程,传统JS模拟类定义,ES6关于类定义 2.要点梳理2.1传统js中推荐使用极简主义法来模拟类123456789101112131415161718192021222324252627282930313233343536373839 // 父类 var Animal = &#123; createNew: function()&#123; var animal = &#123;&#125;; animal.sleep = function()&#123; alert(&quot;睡懒觉&quot;); &#125;; return animal; &#125; &#125;;// 子类继承父类 var Cat = &#123; // 共享属性 voice : &quot;汪汪汪&quot;, createNew: function()&#123; var cat = Animal.createNew(); // 实例属性 cat.name = &quot;大毛&quot;; // 继承的方法重写 cat.sleep = function() &#123; alert(&quot;子类不想睡懒觉&quot;); &#125; // 私有属性 var sound = &quot;喵喵喵&quot;; // 获取私有属性 cat.makeSound = function()&#123; alert(&quot;私有属性:&quot; + sound); &#125;; // 修改共享属性 cat.changeVoice = function(x)&#123;Cat.voice = x;&#125; // 获取共享属性 cat.getVoice = function()&#123; return Cat.voice &#125; return cat; &#125; &#125;;// 实例化对象var cat1 = Cat.createNew();// 继承的方法重写 cat1.sleep();// 私有属性只能通过内部方法调用cat1.makeSound()// 如果有一个实例对象，修改了共享的数据，另一个实例对象也会受到影响。cat2.changeVoice(&quot;哈哈哈&quot;);cat1.getVoice() // 哈哈哈console.log(Cat.voice) // 哈哈哈 2.2ES6风格类的定义1234567891011121314151617181920212223242526&lt;!-- 父类 --&gt;class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; &lt;!-- 静态方法 --&gt; static hello() &#123; console.log(&apos;hello world&apos;); &#125; &lt;!-- 实例方法 --&gt; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;&lt;!-- 子类 --&gt;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); this.color = color; &#125;&#125;&lt;!-- 实例化 --&gt;var obj = new ColorPoint();obj.toString()ColorPoint.hello() 2.3实例练习123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是本来的内容&lt;/div&gt; &lt;div id=&quot;target&quot;&gt;&lt;/div&gt; &lt;script&gt; // 定义类 var RenderContent = &#123; createContent: function()&#123; var renderContent = &#123;&#125; // 动态生成dom renderContent.init = function(el)&#123; el.innerHTML = &quot;&lt;p&gt;我只是插入的dom&lt;/p&gt;&quot; &#125; // 异步callback renderContent.waitTime = function(n, callback)&#123; console.log(&apos;您传入的时间数值是:&apos; + n) console.log(&apos;已进入计时状态,请等候...&apos;) setTimeout(function()&#123; callback(2 * n) &#125;, 2 * n * 1000) &#125; return renderContent &#125; &#125; // 实例化对象 var render1 = RenderContent.createContent() // 调用方法生成dom render1.init(document.getElementById(&apos;target&apos;)) // 调用异步方法:callback // 传入等待时间n,返回等待时间的二倍 render1.waitTime(2, function(m)&#123; console.log(&apos;我等待了2n的时间:&apos; + m) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"RN项目发布至APP Store","date":"2019-06-12T05:14:17.000Z","path":"2019/06/12/ios/","text":"1.文档目的记录RN项目打包生成IOS安装包,并发布至APP Store的过程.参考网址:RN转IOS前期处理,打包开发版,打包发布版本 2.过程记录打包ios实践：2.1 https://www.jianshu.com/p/937daff609eb在ios下新建bundle文件夹在package.json中配置命令1&quot;bundle-ios&quot;:&quot;react-native bundle --entry-file index.js --platform ios --dev false --bundle-output ./ios/bundle/index.ios.jsbundle --assets-dest ./ios/bundle&quot; 运行： yarn run bundle-ios 将assets 和 index.ios.jsbundle 文件引入到xcode工程打开Xcode，在第二个tpa3文件夹上右键单击，add Files to ‘…’[注意选中：Create folder references] 修改Appdelegate中的配置代码如下：12345#if DEBUG jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil];#else jsCodeLocation = [NSURL URLWithString:[[NSBundle mainBundle] pathForResource:@&quot;index.ios.jsbundle&quot; ofType:nil]];#endif RN项目自带的是debug模式，真机打包需要修改为release模式。下图打开快捷键为command+shit+， 2.2 Certificates(哪台电脑可以发布程序) 注意：第一步选择证书类型（Development用于测试，App Store and Ad Hoc用于发布正式版）（1）本电脑生成的证书上传IOS（2）IOS生成的Certificates用于安装 注意：不要忘了双击安装2.3 Identifiers（哪个APP可以被发布）（1）App IDs / yananJzfp / org.reactjs.native.example.tpa3(修改为 com.yanan.jzfp) / [能用的服务都可以先选上]2.4 Devices （哪些设备可以运行真机测试）（1）UDID: 可以通过iTunes查看2.5 Provisioning Profiles （生成总配置文件） 注意：必须选择包含应用程序签名的证书（与第一步的证书相对应）（1）Development开发证书（能全选的尽量全选）（2）Distribution （要选对应的配置文件） 注意：不要忘了双击安装[用于打包环境的改变]2.6 打包过程（1）Xcode中确保有团队账号（Xcode—–》Preferences—–&gt;Accounts）（2）配置Build Settings中Code Signing Identity和Development Team 注意：这里设置的要根据打包类型再General中设置对应的Signing(关注 Provisioning Profile项)，dev版本可以待生成之后再选择（3）左上角“运行”按钮右边的运行环境不能是模拟器，才能点击(Product —-&gt; Archive)","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"模块化","date":"2019-06-11T14:36:22.000Z","path":"2019/06/11/module/","text":"1.文档目的清楚了解模块化在js中的发展和技术更新，有利于对前端技术体系的整体把控。参考文档：阮一峰：模块化编程，ES6模块标准化 2.要点梳理问：什么是模块化？答：模块就是实现特定功能的一组方法(webpack将一切资源都视为模块） 问：es5中如何模拟模块化？答：CommonJS(简称CMD)和AMD,cmd是同步方式，适用于服务器环境，AMD是异步模块定义，两者均采用require()语句加载模块 问：ES6中如何支持模块化？答：export和import是专门为模块化而生的，区别于cmd和amd的运行时，export和import方案则选择了静态化，在编译时就能发现问题。","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"像素级还原设计稿","date":"2019-05-27T05:24:47.000Z","path":"2019/05/27/px/","text":"1.文档目的精准清晰的理论基础有助于培养技术自信。参考网址:像素理论详解,rem 2.内容梳理###2.1 核心概念解读:英寸:屏幕对角线的长度,1英寸=2.54厘米分辨率:表示对象在垂直和水平上像素(物理像素)点数的乘积(注:清晰度还与尺寸有关)PPI:表示每英寸包括的像素(物理像素)数,反映了清晰度设备独立像素:为保证新老设备显示效果基本一致,新设备在增大物理像素的同时,并不增加”设备独立像素”,故1设备独立像素等于若干(@2x,@3x)物理像素.ReactNative开发中样式单位(dp)就是设备独立像素(ios尺寸单位pt,android尺寸单位dp同理),而UI设计的原型图一般是基于iphone6的物理像素,为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素.浏览器开发者工具显示的移动端设备像素就是设备独立像素.web端开发中,当页面缩放比例为100%时,一个css像素就等于一个设备独立像素.设备像素比(dpr):物理像素和设备独立像素的比值视口:布局视口(css依赖的视口),视觉视口(通过屏幕可以看到的区域),理想视口(当页面缩放比例为100%时,理想视口=视觉视口,CSS像素=设备独立像素)安全区域:为圆角,刘海和小黑条设计的解决方案 ###2.2 H5适配手机主要有两个维度：（1）适配不同像素密度(1像素对应多少物理像素,比如3倍屏@3x, 即1px对应9个物理像素[3x3])（2）适配不同大小屏幕问题一：图片如何在3倍屏和2倍屏上显示不失真？答：1个图片像素对应1个物理像素，图片就不会失真[精准匹配需要借助媒体查询等手段]，简单粗暴的适配方案，就是针对所有屏幕，都只提供最高清图片,还有img标签的srcset等高级属性的应用。问题二：如何适配不同大小屏幕？答：原则是确保页面布局的度量与屏幕大小保持一定比例。例如通常设计稿是750像素，我们需要按比例还原（x / 750，eg: 75 / 750 = 10% ）。实践中不能直接用百分比，因为它总是需要一个参照量，而且边框不支持百分比等问题。rem:依赖根元素font-size属性的计算值vw/vh: 1vw= 1%屏幕宽度 完美方案。问题三：如何方便将px转换为vw?答：postcss-px-to-viewport插件","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"layout","date":"2019-05-04T08:46:46.000Z","path":"2019/05/04/layout/","text":"1.文档目的总结css布局规则,首先强调一点是布局由“定位”和“盒模型”两部分组成，这是两个不同的概念。本文首先阐述“定位”与“盒模型”两者之间的关系，然后分别梳理弹性盒子flex，网格布局grid,文档流和定位方式，浮动，盒子模型，媒体查询等主要技能点，不断总结，熟能生巧。参考网址:弹性盒子Flex，网格布局Grid，文档流和定位方式，盒子模型 2.内容梳理2.1“定位”与“盒模型”“定位”和“盒模型”是两个完全不同的概念，但是两者共同作用决定了元素的最终布局。 2.2关于“定位”的相关问题2.2.1Flex布局阮一峰老师对弹性盒子flex布局的讲解很清楚，也很详细，这里不再赘述。下面仅列出通用代码：1234567891011121314151617181920212223&lt;!-- flex布局 --&gt;.flex-box &#123; display: flex; flex-direction: row; flex-wrap: nowrap; justify-content: flex-start; /* 副轴对齐方式 */ align-items: center; /* 多行对齐方式 */ align-content: flex-start;&#125;.flex-item &#123; /* 排序 */ order: 0; /* 放大比例 */ flex-grow: 0; /* 缩小比例 */ flex-shrink: 1; /* 项目占据主轴空间 auto */ flex-basis： 350px; /* 不同对齐方式，覆盖align-items[副轴对齐方式] */ align-self: center;&#125; 2.2.2Grid布局网格布局Grid也是非常常用的布局之一，这里主要强调它与弹性盒模型Flex布局的区别：区别一：弹性盒模型主要用于一维布局（按行或按列），网格布局更适用于二维布局（同时考虑行和列）区别二：弹性盒模型主要从内容出发（内容多少影响布局），网格布局从布局入手（一旦定义，布局确定）下面列出一个常见的基本用法：1234567891011121314151617181920212223&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;box1&quot;&gt;One&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;Two&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;Three&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;Four&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;Five&lt;/div&gt;&lt;/div&gt;.wrapper &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 100px; &#125; .box1 &#123; grid-column-start: 1; grid-column-end: 4; grid-row-start: 1; grid-row-end: 3; &#125; .box2 &#123; grid-column-start: 1; grid-row-start: 3; grid-row-end: 5; &#125; 2.2.3文档流和定位方式该内容是定位的基础，之所以放在第三个讨论的位置，是因为我觉得这个没有什么可讨论的，必须严格掌握。如果非要说点什么的话，那就是下面几种定位方式有着循序渐进的关系,z-index扩展到了三维空间。123456.positioned &#123; position: static; position: absolute; position: fixed; z-index: 1;&#125; 2.3关于“盒模型”的相关问题盒子模型除了最基本的属性外，需要强调的是box-sizing对width的影响。当需要明确width便于计算时，建议设置box-sizing为border-box1234567.box &#123; box-sizing: border-box; width: 50px; height: 50px; padding: 10px; margin: 10px;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"icon","date":"2019-04-21T09:10:14.000Z","path":"2019/04/21/icon/","text":"1.文档目的网络使用图标是很常见的，这里提供一种最简单的方式，来快速获取可用的网络图标。基于阿里图标库。参考网址:阿里图标库iconfont 2.内容梳理使用方法，用github账号登录阿里图标库，查询所需图标，点击“添加入库”,然后打开通用项目common,找到购物车，将库中图标添加至项目，然后选中“font class”生成链接，在web项目中引入图标如下：1&lt;link href=&quot;http://at.alicdn.com/t/font_803606_60a86mpe3nt.css&quot; rel=&quot;stylesheet&quot;&gt; 在项目中使用图标如下（可通过css改变图标大小和颜色）：1&lt;i class=&quot;iconfont icon-jiazheng&quot; style=&quot;color:red;font-size: 55px;&quot;&gt;&lt;/i&gt;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"style","date":"2019-04-21T08:08:26.000Z","path":"2019/04/21/style/","text":"1.文档目的本文基于Bootstrap,收集整理通用style样式，便于快速高效的实现样式效果。该样式适用于web端（非RN），当前很多项目都会自选UI库,各个库都有自己的样式规范，实际开发中要优先考虑UI库样式，然后再将本文整理的通用style样式作为工具和补充。官方提供的bootstrap.min.css样式很多，包含该库组件部分等样式，无特殊要求可直接引入bootstrap.min.css,也可以仅引入我们整理的通用工具类，比如栅格布局，浮动等参考网址:BootStrap全局css样式，bootstrap.min.css 提取码：he9a，bootstrap.css 提取码：khav 2.内容梳理提取通用样式类如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!-- 容器 --&gt;.container &#123; min-width: 992px !important;&#125;&lt;!-- flex布局 --&gt;.flex-box &#123; display: flex; flex-direction: row; flex-wrap: nowrap; justify-content: flex-start; /* 副轴对齐方式 */ align-items: center; /* 多行对齐方式 */ align-content: flex-start;&#125;.flex-item &#123; /* 排序 */ order: 0; /* 放大比例 */ flex-grow: 0; /* 缩小比例 */ flex-shrink: 1; /* 项目占据主轴空间 auto */ flex-basis： 350px; /* 不同对齐方式，覆盖align-items[副轴对齐方式] */ align-self: center;&#125;&lt;!-- 按钮 --&gt;.btn &#123; display: inline-block; font-weight: 400; text-align: center; white-space: nowrap; vertical-align: middle; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; border: 1px solid transparent; padding: 0.375rem 0.75rem; font-size: 1rem; line-height: 1.5; border-radius: 0.25rem; transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;&#125;.btn.focus .btn:focus, &#123; outline: 0; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);&#125;.btn.disabled, .btn:disabled &#123; opacity: 0.65;&#125;.btn:not(:disabled):not(.disabled) &#123; cursor: pointer;&#125;.btn:hover, .btn:focus &#123; text-decoration: none;&#125;.btn-default &#123; color: #333; background-color: #fff; border-color: #ccc;&#125;.btn-primary &#123; color: #fff; background-color: #337ab7; border-color: #2e6da4;&#125;&lt;!-- 文本 --&gt; .text-primary &#123; color: #007bff !important;&#125;.text-light &#123; color: #f8f9fa !important;&#125;.text-dark &#123; color: #343a40 !important;&#125;.font-weight-light &#123; font-weight: 300 !important;&#125;.font-weight-normal &#123; font-weight: 400 !important;&#125;.font-weight-bold &#123; font-weight: 700 !important;&#125;.font-h1 &#123; font-size: 22px;&#125; .font-h2 &#123; font-size: 20px;&#125; .font-h3 &#123; font-size: 18px;&#125; .font-h4 &#123; font-size: 16px;&#125; .font-h5 &#123; font-size: 14px;&#125; .font-h6 &#123; font-size: 12px;&#125;&lt;!-- 超链接 --&gt;&lt;!-- link 未被访问visited 已被访问hover 鼠标指针移动到链接上active 正在被点击的链接focus 元素获取焦点 --&gt;a.text-primary:link,a.text-primary:visited,a.text-primary:hover,a.text-primary:active,a.text-primary:focus &#123; color: #007bff !important; text-decoration: none;&#125;&lt;!-- 1px边框 --&gt; .border_1px:before&#123; content: &apos;&apos;; position: absolute; top: 0; height: 1px; width: 100%; background-color: #000; transform-origin: 50% 0%;&#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px:before&#123; transform:scaleY(0.5); &#125;&#125; @media only screen and(-webkit-min-device-pixel-ratio:3)&#123; .border_1px:before&#123; transform:scaleY(0.33); &#125;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"json","date":"2019-04-11T04:14:03.000Z","path":"2019/04/11/json-server/","text":"1.文档目的汇总前端JSON数据模拟技术,本文介绍三种技术:json server, Easy mock, github api v3.json server: 该方式采用本地编写JSON文件,并通过本地web服务器请求的方式来模拟请求Easy Mock: 在线json模拟数据生成管理平台github api v3:获取并操作github账号下个人相关信息的接口服务实际上获取网络接口和网络图片资源的方式比较灵活,比如随便在网络上打开开发模式都可以看到get请求,而且get接口链接直接在浏览器中打开就可以获得数据,图片资源更简单,百度搜索的图片,单击右键就可以获得图片链接,直接在浏览器中打开图片链接就可以看到图片资源.参考网址: json-server的使用,Easy Mock官网,github api讲解,github api官方文档 2.实践过程2.1 json server安装依赖1npm install -g json-server 查看版本1json-server -v 创建db.json123456789&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125; 启动服务1json-server db.json 在postman或浏览器中访问接口,比如:1http://localhost:3000 2.2 East Mock只需要打开East Mock官网,登录账号并编辑JSON数据,然后用浏览器,postman,axios等请求即可 2.3 github api该方式请求的接口由github官方提供服务,数据是个人行为在github平台上产生的真实数据,下面仅列出实用接口,便于调用用户信息[详情信息]1https://api.github.com/users/ruanyf 列表信息[分页/不分页]1https://api.github.com/users/ruanyf/followers?page=1&amp;per_page=10 占位图1http://temp.im/288x288","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"基于React Native在应用中查看PDF文档","date":"2019-04-04T04:30:06.000Z","path":"2019/04/04/pdf-view/","text":"1.文档目的记录在RN中查看PDF的实践经验,便于后期参考.其原理是先从网络上下载pdf资源,然后在应用中打开查看.[注:根据PDF显示实例,不用下载也可以直接加载网络pdf资源,值得进一步探究]参考网址: react-native-fs文件下载,react-native-pdf PDF查看 2.实践过程安装依赖1yarn add react-native-fs 挂载,根据提示可能需要再执行一个命令,若执行一次不成功,则再次尝试1react-native link react-native-fs 然后即可在项目中引入使用1import RNFS from &apos;react-native-fs&apos;; 下载文档12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*下载文件*/ downloadFile() &#123; // On Android, use &quot;RNFS.DocumentDirectoryPath&quot; (MainBundlePath is not defined) // 图片 // const downloadDest = `$&#123;RNFS.MainBundlePath&#125;/$&#123;((Math.random() * 1000) | 0)&#125;.jpg`; // const formUrl = &apos;http://img.kaiyanapp.com/c7b46c492261a7c19fa880802afe93b3.png?imageMogr2/quality/60/format/jpg&apos;; // 文件 // const downloadDest = `$&#123;RNFS.MainBundlePath&#125;/$&#123;((Math.random() * 1000) | 0)&#125;.zip`; // const formUrl = &apos;http://files.cnblogs.com/zhuqil/UIWebViewDemo.zip&apos;; // 视频 // const downloadDest = `$&#123;RNFS.MainBundlePath&#125;/$&#123;((Math.random() * 1000) | 0)&#125;.mp4`; // http://gslb.miaopai.com/stream/SnY~bbkqbi2uLEBMXHxGqnNKqyiG9ub8.mp4?vend=miaopai&amp; // https://gslb.miaopai.com/stream/BNaEYOL-tEwSrAiYBnPDR03dDlFavoWD.mp4?vend=miaopai&amp; // const formUrl = &apos;https://gslb.miaopai.com/stream/9Q5ADAp2v5NHtQIeQT7t461VkNPxvC2T.mp4?vend=miaopai&amp;&apos;; // 音频 const downloadDest = `$&#123;RNFS.MainBundlePath&#125;/$&#123;((Math.random() * 1000) | 0)&#125;.mp3`; // http://wvoice.spriteapp.cn/voice/2015/0902/55e6fc6e4f7b9.mp3 const formUrl = &apos;http://wvoice.spriteapp.cn/voice/2015/0818/55d2248309b09.mp3&apos;; const options = &#123; fromUrl: formUrl, toFile: downloadDest, background: true, begin: (res) =&gt; &#123; console.log(&apos;begin&apos;, res); console.log(&apos;contentLength:&apos;, res.contentLength / 1024 / 1024, &apos;M&apos;); &#125;, progress: (res) =&gt; &#123; let pro = res.bytesWritten / res.contentLength; this.setState(&#123; progressNum: pro, &#125;); &#125; &#125;; try &#123; const ret = RNFS.downloadFile(options); ret.promise.then(res =&gt; &#123; console.log(&apos;success&apos;, res); console.log(&apos;file://&apos; + downloadDest) // 例如保存图片 CameraRoll.saveToCameraRoll(downloadDest) .then(()=&gt;&#123; Toast.showShortCenter(&apos;图片已保存到相册&apos;) &#125;).catch(()=&gt;&#123; Toast.showShortCenter(&apos;图片保存失败&apos;) &#125;) &#125;).catch(err =&gt; &#123; console.log(&apos;err&apos;, err); &#125;); &#125; catch (e) &#123; console.log(error); &#125; &#125; PDF文档的查看,首先也要安装依赖12345yarn add rn-fetch-blobyarn add react-native-pdfreact-native link rn-fetch-blobreact-native link react-native-pdf 然后就可以尝试显示PDF资源123456789101112131415161718192021222324252627282930313233343536373839404142434445import React from &apos;react&apos;;import &#123; StyleSheet, Dimensions, View &#125; from &apos;react-native&apos;; import Pdf from &apos;react-native-pdf&apos;; export default class PDFExample extends React.Component &#123; render() &#123; const source = &#123;uri:&apos;http://samples.leanpub.com/thereactnativebook-sample.pdf&apos;,cache:true&#125;; //const source = require(&apos;./test.pdf&apos;); // ios only //const source = &#123;uri:&apos;bundle-assets://test.pdf&apos;&#125;; //const source = &#123;uri:&apos;file:///sdcard/test.pdf&apos;&#125;; //const source = &#123;uri:&quot;data:application/pdf;base64,...&quot;&#125;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Pdf source=&#123;source&#125; onLoadComplete=&#123;(numberOfPages,filePath)=&gt;&#123; console.log(`number of pages: $&#123;numberOfPages&#125;`); &#125;&#125; onPageChanged=&#123;(page,numberOfPages)=&gt;&#123; console.log(`current page: $&#123;page&#125;`); &#125;&#125; onError=&#123;(error)=&gt;&#123; console.log(error); &#125;&#125; style=&#123;styles.pdf&#125;/&gt; &lt;/View&gt; ) &#125;&#125; const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;flex-start&apos;, alignItems: &apos;center&apos;, marginTop: 25, &#125;, pdf: &#123; flex:1, width:Dimensions.get(&apos;window&apos;).width, &#125;&#125;);","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"echarts","date":"2019-03-27T04:23:39.000Z","path":"2019/03/27/echarts/","text":"1.文档目的维护一个简单的图表模板,积累常用参数,便于快速配置图表参考网址:echarts门户网站 2.内容梳理图表基础模板(基于vue):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;chart demo&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/mint-ui.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../styles/global.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;chart&quot; class=&quot;container&quot;&gt; &lt;!-- chart1 条形图 --&gt; &lt;div ref=&quot;chart1&quot; style=&quot;width: 100%;height:300px;&quot;&gt;&lt;/div&gt; &lt;!-- chart2 饼状图 --&gt; &lt;div ref=&quot;chart2&quot; style=&quot;width: 100%; height: 270px;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../../script/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../script/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../script/echarts.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../script/httpRequest.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../script/constants.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = () =&gt; &#123; document.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123; const &#123; token, areaId &#125; = JSON.parse(data) if (window.postMessage) &#123; let message = &#123; loadFinish: true &#125; window.postMessage(JSON.stringify(message)) &#125; &#125;) &#125; let indexVue = new Vue(&#123; el: &apos;#chart&apos;, data() &#123; return &#123;&#125; &#125;, methods: &#123; initChart() &#123; // 条形图 let chart1 = echarts.init(this.$refs[&apos;chart1&apos;]) let chartOptions1 = &#123; title: &#123; text: &apos;大国人口&apos;, textStyle: &#123; color: &apos;#39a3d5&apos;, fontSize: 14 &#125; &#125;, color: [ &apos;#7199D6&apos;, &apos;#DB7D36&apos;, &apos;#82AB4E&apos;, &apos;#9CABE1&apos;, &apos;#F0B885&apos;, &apos;#739BD6&apos;, &apos;#72C4CC&apos;, &apos;#B1A3DE&apos;, &apos;#78B0ED&apos;, &apos;#E0A1B6&apos;, &apos;#F1C026&apos; ], // 对点击时显示的tip就行配置 tooltip: &#123; trigger: &apos;item&apos;, formatter: &apos;&#123;a&#125; &lt;br/&gt;&#123;b&#125;:&#123;c&#125;&apos; &#125;, // 配置图例边距留白距离,是否包含坐标轴刻度 grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125;, xAxis: &#123; axisLabel: &#123; rotate: 0, interval: 0 &#125; &#125;, yAxis: &#123; data: [&apos;巴西&apos;, &apos;印尼&apos;, &apos;美国&apos;, &apos;印度&apos;, &apos;中国&apos;], // 对y坐标轴显示的刻度进行配置 axisLabel: &#123; rotate: 0, interval: 0 &#125; &#125;, series: [ &#123; name: &apos;人数&apos;, type: &apos;bar&apos;, data: [18203, 23489, 29034, 104970, 131744] &#125; ] &#125; chart1.setOption(chartOptions1) // 饼状图 let chart2 = echarts.init(this.$refs[&apos;chart2&apos;]) let chartOptions2 = &#123; title: &#123; text: &apos;社会资源分布&apos;, textStyle: &#123; color: &apos;#39a3d5&apos;, fontSize: 14 &#125; &#125;, color: [ &apos;#7199D6&apos;, &apos;#DB7D36&apos;, &apos;#82AB4E&apos;, &apos;#9CABE1&apos;, &apos;#F0B885&apos;, &apos;#739BD6&apos;, &apos;#72C4CC&apos;, &apos;#B1A3DE&apos;, &apos;#78B0ED&apos;, &apos;#E0A1B6&apos;, &apos;#F1C026&apos; ], // 对点击时显示的tip就行配置 tooltip: &#123; trigger: &apos;item&apos;, formatter: &apos;&#123;a&#125; &lt;br/&gt;&#123;b&#125;:&#123;c&#125; (&#123;d&#125;%)&apos; &#125;, // 对图例的显示位置等内容进行配置 legend: &#123; // horizontal, vertical orient: &apos;horizontal&apos;, bottom: &apos;5%&apos; &#125;, series: [ &#123; name: &apos;占比&apos;, type: &apos;pie&apos;, radius: &apos;50%&apos;, center: [&apos;50%&apos;, &apos;40%&apos;], data: [ &#123; value: 335, name: &apos;直接访问&apos; &#125;, &#123; value: 310, name: &apos;邮件营销&apos; &#125;, &#123; value: 234, name: &apos;联盟广告&apos; &#125;, &#123; value: 135, name: &apos;视频广告&apos; &#125;, &#123; value: 1548, name: &apos;搜索引擎&apos; &#125; ], label: &#123; normal: &#123; // 是否显示每个扇形指示 show: false, // 若显示,则对过长内容格式化处理 formatter(v) &#123; let text = v.name return text.length &lt; 4 ? text : `$&#123;text.slice(0, 4)&#125;\\n$&#123;text.slice(4)&#125;` &#125; &#125; &#125; &#125; ] &#125; chart2.setOption(chartOptions2) &#125; &#125;, mounted() &#123; this.initChart() &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"color","date":"2019-03-26T04:32:40.000Z","path":"2019/03/26/theme/","text":"1.文档目的收集整理常用样式,便于通用配置出简约大气的页面，下面仅选取Flat UI库作为代表性的颜色值，举一反三，当前项目使用了什么UI库，那么自己也应该抽取该库中Colors文件中的颜色值，作为项目的全局颜色值，这样有利于保持项目色调的统一（例如BootStrap主题色）。参考网址:Flat UI 色表,香港地铁色,经验配色法则 2.内容梳理经验配色法效果图及其颜色值如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;h3&gt;图层灰:背景, 列表项&lt;/h3&gt;&lt;div class=&quot;flex-box&quot;&gt; &lt;span style=&quot;background: #aaaaaa&quot;&gt;aaaaaa&lt;/span&gt; &lt;span style=&quot;background: #bbbbbb&quot;&gt;bbbbbb&lt;/span&gt; &lt;span style=&quot;background: #cccccc&quot;&gt;cccccc&lt;/span&gt; &lt;span style=&quot;background: #dddddd&quot;&gt;dddddd&lt;/span&gt; &lt;span style=&quot;background: #eeeeee&quot;&gt;eeeeee&lt;/span&gt;&lt;/div&gt;&lt;h3&gt;文字黑: 分级标题&lt;/h3&gt;&lt;div class=&quot;flex-box&quot;&gt; &lt;span style=&quot;background: #1a2a3a&quot;&gt;1a2a3a&lt;/span&gt; &lt;span style=&quot;background: #2a3a4a&quot;&gt;2a3a4a&lt;/span&gt; &lt;span style=&quot;background: #333333&quot;&gt;333333&lt;/span&gt; &lt;span style=&quot;background: #3a4a5a&quot;&gt;3a4a5a&lt;/span&gt; &lt;span style=&quot;background: #4a5a6a&quot;&gt;4a5a6a&lt;/span&gt;&lt;/div&gt;&lt;h3&gt;主题深:cf69&lt;/h3&gt;&lt;div class=&quot;flex-box&quot;&gt; &lt;span style=&quot;background: #9966ff&quot;&gt;9966ff&lt;/span&gt; &lt;span style=&quot;background: #6666ff&quot;&gt;6666ff&lt;/span&gt; &lt;span style=&quot;background: #66ff99&quot;&gt;66ff99&lt;/span&gt; &lt;span style=&quot;background: #6699ff&quot;&gt;6699ff&lt;/span&gt;&lt;/div&gt;&lt;h3&gt;主题浅:cf69&lt;/h3&gt;&lt;div class=&quot;flex-box&quot;&gt; &lt;span style=&quot;background: #ffff66&quot;&gt;ffff66&lt;/span&gt; &lt;span style=&quot;background: #ffcc66&quot;&gt;ffcc66&lt;/span&gt; &lt;span style=&quot;background: #ff9966&quot;&gt;ff9966&lt;/span&gt; &lt;span style=&quot;background: #ff6666&quot;&gt;ff6666&lt;/span&gt;&lt;/div&gt;&lt;h3&gt;主题灰:abcdef&lt;/h3&gt;&lt;div class=&quot;flex-box&quot;&gt; &lt;span style=&quot;background: #abcdef&quot;&gt;abcdef&lt;/span&gt; &lt;span style=&quot;background: #bedcaf&quot;&gt;bedcaf&lt;/span&gt; &lt;span style=&quot;background: #cafedb&quot;&gt;cafedb&lt;/span&gt; &lt;span style=&quot;background: #decafb&quot;&gt;decafb&lt;/span&gt;&lt;/div&gt;.flex-box &#123; display: flex; margin-top: 10px;&#125;.flex-box span&#123; margin-right: 5px;&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"基于RN的安卓权限配置","date":"2019-03-25T04:26:09.000Z","path":"2019/03/25/android-manifest/","text":"1.文档目的基于React Native的权限配置,在开发安卓app的过程中需要访问安卓手机硬件服务的时候,都会用到权限,比如拍照,定位,手机通讯录等,这里只记录添加安卓权限的例子,ios暂不考虑 2.内容梳理权限配置文件android/app/src/main/AndroidManifest.xml,添加对应权限如下:1&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 那么在具体逻辑中需要用到该权限时,手机就会自动询问用户是否允许开启该权限,具体逻辑如下:12345_getCurrentLocation = async () =&gt; &#123; navigator.geolocation.getCurrentPosition(location =&gt; &#123; console.log(location) &#125;) &#125;","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"基于React Native的android打包","date":"2019-03-19T04:39:12.000Z","path":"2019/03/19/android-apk/","text":"1.文档目的打包生成apk安装包配置历来比较复杂,这里简单记录入门配置,方便查看.打包IOS，需要有打包证书支持,这里先不做探究.打安卓包，默认初始化的RN项目，不修改任何配置的情况下，首次打包会下载很多依赖，而且会提示成功，但是并不会打包出apk安装包。经过以下配置之后，可以打包成功，并运行成功。 2.内容梳理步骤一:配置android/app/build.gradle文件,如图一所示 图（1）12345678910 signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125;signingConfig signingConfigs.release 步骤二:配置android/gradle.properties文件,如图二所示 图（2）1234567MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=123456789MYAPP_RELEASE_KEY_PASSWORD=123456789 步骤三:在android/app/文件夹下添加key文件my-release-key.keystore 提取码: ncpe","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"基于React Native的热更新","date":"2019-03-15T04:56:32.000Z","path":"2019/03/15/code-push/","text":"1.文档目的基于React Native的热更新,使用react-native-code-push,这里先记录其最基本的用法,便于工作查阅,后期再逐步完善其配置和用法参考网址: react-native-code-push常用命令 2.发布热更新等常用命令查看服务器app部署情况1code-push app list 查看发布信息1code-push deployment ls Rasog-android -k 发布命令1code-push release-react Rasog-android android --t 1.0.0 --d Staging --des &quot;1.调整新增整治清单字段\\n2.调整编辑整治清单时照片可删除&quot; --m true 其他常用命令 code-push app add 在账号里面添加一个新的app code-push app remove 或者 rm 在账号里移除一个app code-push app rename 重命名一个存在app code-push app list 或则 ls 列出账号下面的所有app code-push app transfer 把app的所有权转移到另外一个账号 code-push app ls 查看已注册的应用 code-push deployment ls appName -k 查看应用key code-push login 登陆 code-push loout 注销 code-push access-key ls 列出登陆的token code-push access-key rm 删除某个 access-key code-push app add react-native 在账号里面添加一个新的app code-push app remove 或者 rm 在账号里移除一个 app code-push app rename 重命名一个存在 app code-push app list 或则 ls 列出账号下面的所有 app code-push app transfer 把app的所有权转移到另外一个账号 code-push deployment add 部署 code-push deployment rm 删除部署 code-push deployment rename 重命名 code-push deployment ls 列出应用的部署情况 code-push deployment ls -k 查看部署的key code-push deployment history 查看历史版本3.配置本地部署 登录本地服务 code-push login http://61.185.20.20:2312/ （公网地址）、 会自动打开浏览器 登录后 点击获取token， 在 Enter your token from the browser: 输入 获取的token Successfully logged-in. Your session file was written to /Users/xxxx/.code-push.config. You can run the code-push logout command at any time to delete this file and terminate your session. 本地私有化部署方案参考：https://www.cnblogs.com/shuoer/p/9581886.html 在CodePush服务器注册app，为了让CodePush服务器知道你的app，我们需要向它注册app： 在终端输入code-push app add &lt;appName&gt;即可完成注册；私有化服务器要求的参数更多code-push app add &lt;appName&gt; &lt;os&gt; &lt;platform&gt;，并且appName要加-android或者-ios结尾，然后是平台，最后加上是react-native或者Cordova，因为code-push支持这两种应用,例如: 1code-push app add Rasog-android android react-native 成功后： 12345678Successfully added the \"Rasog-android\" app, along with the following default deployments:┌────────────┬───────────────────────────────────────┐│ Name │ Deployment Key │├────────────┼───────────────────────────────────────┤│ Production │ 4ZfN5udhhOftT2ND95gHZr98nmyA4ksvOXqog │├────────────┼───────────────────────────────────────┤│ Staging │ ZymGYYCM6PMwHlwDWef9zCXu8LbC4ksvOXqog │└────────────┴───────────────────────────────────────┘ 注册完成之后会返回一套deployment key，分为生成环境Production和Staging，该key在后面客户端集成sdk中会用到。 集成CodePush SDK (for Android) 在项目中安装react-native-code-push插件 12yarn add react-native-code-pushreact-native link react-native-code-push 在终端运行此命令之后，终端会提示让你输入deployment key，这是你只需将你的deployment Staging key输入进去即可 Link 完成后会自动添加一些代码。因为服务是私有部署，需要修改 更新地址。修改android/app/src/main/java/MainApplication.java文件 12345678@Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CodePush(getResources().getString(R.string.reactNativeCodePush_androidDeploymentKey), getApplicationContext(), BuildConfig.DEBUG,\"http://61.185.20.20:2312\"), ..... ); &#125; 在new CodePush()最后添加一个参数就是本地服务的地址。 修改rn工程的 入口文件。 123456789101112131415161718192021222324252627282930313233// 导入code-pushimport CodePush from 'react-native-code-push'const codePushOptions = &#123; checkFrequency: CodePush.CheckFrequency.ON_APP_RESUME &#125;// CodePush 是一个高阶组件 还包含一些方法。// synccomponentDidMount () &#123; this._updateApp() AppState.addEventListener('change', newState =&gt; &#123; newState === 'active' &amp;&amp; this._updateApp() &#125;) &#125; // code-push 热更新 _updateApp = () =&gt; &#123; CodePush.sync(&#123; installMode: CodePush.InstallMode.IMMEDIATE, // 启动模式三种：ON_NEXT_RESUME、ON_NEXT_RESTART、IMMEDIATE updateDialog: &#123; appendReleaseDescription: true, // 是否显示更新description，默认为false descriptionPrefix: '更新内容：\\n', // 更新说明的前缀。 默认是” Description: mandatoryContinueButtonLabel: '立即更新', // 强制更新的按钮文字，默认为continue mandatoryUpdateMessage: '', // - 强制更新时，更新通知. Defaults to “An update is available that must be installed.”. optionalIgnoreButtonLabel: '稍后', // 非强制更新时，取消按钮文字,默认是ignore optionalInstallButtonLabel: '更新', // 非强制更新时，确认文字. Defaults to “Install” optionalUpdateMessage: '有新版本了，是否更新？\\n', // 非强制更新时，更新通知. Defaults to “An update is available. Would you like to install it?”. title: '更新提示' // 要显示的更新通知的标题. Defaults to “Update available”. &#125; &#125;) &#125;//最后导出组件时，需要被CodePush包裹export default CodePush(codePushOptions)(App) 至此就完成了 code-push for android 的配置。 1code-push release-react MyAppAndroid android --t 1.0.0 --dev false --d Production --des \"更新测试\" --m true","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"serve静态资源服务器","date":"2019-03-14T04:36:57.000Z","path":"2019/03/14/serve/","text":"1.文档目的前后端分离式的开发模式,使得前端独立于后端搭建开发模式至关重要,有些功能只能借助于服务器才能实现,此时就不能只是打开静态文件了,这里介绍一款极为轻量级的前端静态服务器serve,便于后期查看使用 2.内容梳理全局安装1yarn global add serve 查看版本信息1serve --version 进入需要开启服务的文件夹,启动服务1serve .","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"React+Redux模式","date":"2018-12-25T22:15:26.000Z","path":"2018/12/26/redux/","text":"1.文档目的学习并理解React+Redux模式参考网址：慕课网:在React中使用Redux数据流 2.概念笔记1.React是纯V层框架（页面由容器组件和视图组件构成，本身是个类的定义，有props和state属性，reader和生命周期方法），需要数据流支撑（用户行为和系统响应可预测的抽象，Redux是单向数据流的实现方式之一）2.Redux由action(行为的抽象)和唯一的store[state(可预测,运行时产生)、Reducer(对响应抽象的纯方法，输入state和action,返回新的state)]组成，实现时预先定义好action和reducer,reducer再生产store,action作用于store,store会促使reducer生成新的state","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"axios","date":"2018-12-20T23:11:54.000Z","path":"2018/12/21/axios/","text":"1.文档目的通过对axios几个点的深入剖析和实践，进一步理解前后端配合完成接口对接工作参考网址：axios 2.实践要点分析1.get请求直接拼接动态数据get请求是最常见的请求方式，但是根据后端接口的设计形式，前端请求的方式也是有所区别的，直接拼接动态参数相当于vue router中动态路由且用params传值的形式（如：root/:id）例如在Swagger UI上看到的形式为：【GET】 /resourceApply/get/{id}(Parameters) id[required] string那么前端的请求方法声明就应该如下（即：将参数直接拼接）：1getDepartById = id =&gt; this.get(`/resourceApply/get/$&#123;id&#125;`) 对该方法的调用如下（即：通过形参将动态数据直接传到动态拼接的请求链接上）：1DepartApi.getDepartById(rowId) 2.get等请求params参数形式params参数形式有别于直接链接拼接的形式,该形式会在链接中以？链接各个参数，相当于vue router中用query传值（不涉及路由），需要提醒的是该方式并不是get特有，其实任何请求方式都可以有该参数，包括post,只不过该参数传递的值会包括在请求头中，而data传递的值会在请求体中例如在Swagger UI上看到的get请求形式为：【GET】 /role/findPermsByRoleId(Parameters) roleId[required] string那么前端的请求方法声明和调用方法就应该如下(Swagger上非拼接方式，string形参要求参数名一一对应):12findPermsByRoleId = (params) =&gt; this.get(&apos;dce-admin/role/findPermsByRoleId&apos;, params)DepartApi.findPermsByRoleId(&#123;roleId: this.$route.param.id&#125;) 或如下：12findPermsByRoleId = (roleId) =&gt; this.get(&apos;dce-admin/role/findPermsByRoleId&apos;, &#123; roleId &#125;)DepartApi.findPermsByRoleId(this.$route.param.id) 或如下：12findPermsByRoleId = (roleId) =&gt; this.get(&apos;dce-admin/role/findPermsByRoleId&apos;, &#123; roleId: roleId &#125;)DepartApi.findPermsByRoleId(this.$route.param.id) post请求也是可以有params参数的(data可以默认为{}，来占位)：12subAudit = (data, params) =&gt; this.post(&apos;/dce-res/resourceDB/subAudit&apos;, data, params)DbRegisterApi.subAudit(&#123;&#125;, &#123; resourceDBId: params.row.id &#125;) 3.post等请求data参数形式data 是作为请求主体被发送的数据，只适用于这些请求方法 ‘PUT’, ‘POST’, 和 ‘PATCH’必须是以下类型之一： string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams 浏览器专属：FormData, File, Blob[这些请求方式可能需要显示设置请求头或者对参数进行特殊处理] Node 专属： Stream例如在Swagger UI上看到的形式为(注意post请求体为body类型，故该参数不需要对应字段名称)：【POST】 /dce-admin/depart(Parameters) depart[required] body那么前端的请求方法声明和调用方法就应该如下：12addDepart = data =&gt; this.post(&apos;/dce-admin/depart&apos;, data)DepartApi.addDepart(this.formValidate) 当然，更为复杂的请求形式多种多样，都是以上各种方式的组合，要理解其原理，方能随机应变4.跨域等问题的处理跨域原因：浏览器对于javascript的同源策略【相同协议,相同域名,相同端口】的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据解决方案（在axios请求配置中加入如下配置）：1234567891011// &apos;proxy&apos; 定义代理服务器的主机名称和端口// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: : &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;,","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"coding-quality","date":"2018-12-18T22:43:00.000Z","path":"2018/12/19/coding-quality/","text":"1.文档目的一直想写一篇关于编码习惯和编码质量的博文，却一直没有动手，今天终于开启了这个课题的探究，可能这种情怀就像是一个有洁癖的人对于卫生环境的追求一样，作为一个编码人员也会对自己编写的代码有一种追求质量的情怀。可能这种追求并不是一两天或者几句话能说明白的事情，所有我会持续探究并完善这篇博文，希望可以有所帮助参考网址：雅虎军规35条、JavaScript 编码规范、eslint规则、js编码风格（阮一峰）ES6编程风格 2.心得编程讲究章法，要心中有想法，才能动手编码，正所谓”三思而后行”，而对于编程习惯，还是要尽可能准守一些普遍认同的规则好，而不必过于吹毛求疵，因为可能很多人有不同的观点，特别是看了阮一峰老师关于“js编码风格”一文，以及下方的评论时，感触很大，故此事不可过于偏执。另外需要特别提醒的一点是现在都用es6的编程风格了，但是上线之前都应该将代码统一处理成es5基于node开发环境转换：Babel在线转换：Babel、Traceur1、前端的发展讲究”工程化”，”模块化”和”组件化”，那么我们在编码之前，清晰地了解需求之后，就要从这三个维度去考虑实现方案，工程化：用做工程的思维看待和开发自己的项目，而不再是直接撸起袖子一个页面一个页面开写，比如规划各种规范、技术选型、项目构建优化等等模块化：强调功能的分离同时可以复用，比如ES6 Module,less mixin等，要写一个实现A功能的JS代码，这个功能在项目其他位置也需要用到，那么我们就可以把这个功能看成一个模块采用一定的方式进行模块化编写组件化：强调视图的复用同时需用分离，比如vue公共组件的实现，页面只不过是组件的容器，负责组合组件形成功能完整的界面2、细节决定了编码的质量，而强有力且公认的编码习惯则决定了代码的可读性，常见的编码习惯涉及到文件命名，变量命名，标点符号，注释，代码算法结构等 3.编程命名规则介绍驼峰命名法：如exampleName帕斯卡命名法：如ExampleName下划线命名法：如example_name中划线命名法：如example-name匈牙利命名法(体现类型)：如g_example_name或aExampleNames 3.整理实用条款1、工程化，模块化，组件化的思想2、项目命名使用中划线命名法,比如twitter-bootstrap3、项目中文件夹命名使用中划线命名法：比如global-api3、项目中文件名称命名（除特殊约定外：比如README.md）使用中划线：error-info.js3.1、如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致，比如：import CheckBox from ‘./CheckBox’4、类名用帕斯卡命名法：比如AdminUser{}5、对象、函数、实例、普通变量应该使用驼峰命名法：比如getInit()6、变量命名原则：尽可能短且体现值得类型，即普通变量更适合用匈牙利命名法7、常量命名原则：全部大写且用下划线连接，如USER_TYPE 4.代码开发和维护好的代码设计架构，是易于维护的（易于修改，易于扩展），首次开发新功能时就应该注重设计原则并写出高质量代码，及时做好注释必不可少 代码维护原则：老业务不合理[在确保该代码模块在其他模块不受影响下，可以直接修改原代码，否则应按新需求原则进行]新需求[尽量不要改动原代码，做好注释]（1）尽量通过继承，适配器，桥接等模式，装饰者模式，外观模式，代理模式，组合模式，代码复用模式等方式扩展新需求（2）必须在源代码上修改：做好代码隔离if等","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"sleep-quality","date":"2018-12-18T22:24:35.000Z","path":"2018/12/19/sleep-quality/","text":"1.文档目的该文档用于提醒自己掌握科学的睡眠方法，提升睡眠质量参考网址：乐哈健康:提升睡眠质量 2.提升睡眠质量九大原则1、改掉睡前吃东西的习惯2、调整睡眠环境3、改变睡姿4、睡前梳梳头5、睡前用热水泡泡脚6、蜂蜜加牛奶改善睡眠质量7、临睡前要注意放松心情8、睡前舒缓运动消除疲劳9、睡觉时枕头别垫太高","tags":[{"name":"life","slug":"life","permalink":"http://yoursite.com/tags/life/"}]},{"title":"string","date":"2018-11-19T12:04:20.000Z","path":"2018/11/19/string/","text":"1.文档目的熟练掌握js字符串属性和方法，熟能生巧参考文档：MDN String 2.String一览String.prototype.constructorString.prototype.length 返回了字符串的长度N 用于访问第N个位置的字符，其中N是小于 length 和 0之间的正整数（小下标，起了大作用）String() 将其它对象转化为字符串 【布尔类型】String.prototype.includes() 判断一个字符串里是否包含其他字符串【布尔类型】String.prototype.indexOf() 返回首个被发现的给定值的索引值，如果没有找到则返回-1。【布尔类型】String.prototype.lastIndexOf() 同上，相反【布尔类型】String.prototype.startsWith() 判断一个字符串的结尾是否包含其他字符串中的字符【布尔类型】String.prototype.endsWith() 同上，相反【布尔类型】String.prototype.match() 使用正则表达式与字符串相比较【布尔类型】String.prototype.search() 对正则表达式和指定字符串进行匹配，返回第一个出现的匹配项的下标。【布尔类型】String.prototype.replace() 正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。【新字符串】String.prototype.padStart() 在当前字符串头部填充指定的字符串， 达到指定的长度。 返回新字符串。【新字符串】String.prototype.padEnd() 同上，相反【新字符串】String.prototype.repeat() 返回指定重复次数的由元素组成的字符串对象。【新字符串】String.prototype.slice() 摘取一个字符串区域，返回一个新的字符串。【新字符串】String.prototype.substr() 返回一个字符串中从指定位置开始到指定字符数的字符【新字符串】String.prototype.substring() 返回在字符串中指定两个下标之间的字符。【新字符串】String.prototype.concat() 连接两个字符串文本，并返回一个新的字符串。String.prototype.charAt() 返回特定位置的字符。String.prototype.split() 将字符串对象分割成字符串数组。 String.prototype.toLowerCase() 转化为小写String.prototype.toLocaleLowerCase() 转为本地化小写String.prototype.toUpperCase() 同上，相反String.prototype.toLocaleUpperCase() 同上，相反String.prototype.trim() 从字符串的开始和结尾去除空格。String.prototype.trimLeft() 从字符串的左侧去除空格String.prototype.trimRight() 从字符串的右侧去除空格 String.prototype.toString() 返回用字符串对象的字符串值String.prototype.valueOf() 返回特定对象的原始值（同toString()） String是基本类型，Array是引用类型 总结:1.一些列布尔类型的方法2.一些列对值的增删改查及遍历3.数组和字符串可以相互转化toString join 和 split有空多看看，熟能生巧 扩展学习:splice 和 sort forEach() 遍历数组for .. in 遍历obj的keyfor… of 遍历obj的value","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"array","date":"2018-11-19T11:55:59.000Z","path":"2018/11/19/array/","text":"1.文档目的熟练掌握js数组属性和方法，熟能生巧参考文档：MDN Array 2.Array一览array 数组 【联想记忆法:部署兵力，我就是将军】【方法的分类方法，是否改变数组自身，是否是判断类型的】Array.lengthArray.prototype【布尔类型】Array.isArray() 用来判断某个变量是否是一个数组对象【新数组】Array.from() 从类数组对象或者可迭代对象中创建一个新的数组实例【新数组】Array.of() 根据一组参数来创建新的数组实例，支持任意的参数数量和类型 修改器方法会改变调用它们的对象自身的值：Array.prototype.shift() 【杀掉排头兵】删除数组的第一个元素，并返回这个元素Array.prototype.unshift() 【不要杀掉排头兵，要新增】开头增加一个或多个元素Array.prototype.push() 【push:增加,大规模增加兵力】在数组的末尾增加一个或多个元素，并返回数组的新长度。Array.prototype.pop() 【pop:拿出来，剔除】删除数组的最后一个元素，并返回这个元素Array.prototype.copyWithin() 在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。Array.prototype.fill() 【fill:填满，装满】将数组中指定区间的所有元素的值，都替换成某个固定的值Array.prototype.reverse() 【翻转排兵布阵】 颠倒数组中元素的排列顺序 访问方法不会改变调用它们的对象的值【布尔类型】Array.prototype.includes() 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。【布尔类型】Array.prototype.indexOf() 【index：标志，给兵编号】返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1【布尔类型】Array.prototype.lastIndexOf() 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。【新数组】Array.prototype.slice() 【slice：分出一小队】抽取当前数组中的一段元素组合成一个新数组。【新数组】Array.prototype.concat() 【concat：合并，会师】返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。Array.prototype.toString() 返回一个由所有数组元素组合而成的字符串Array.prototype.toLocaleString() 返回一个由所有数组元素组合而成的本地化后的字符串Array.prototype.join() 【join：连接成绳索】连接所有数组元素组成一个字符串。 迭代方法【布尔类型】Array.prototype.find() 找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined【布尔类型】Array.prototype.findIndex() 找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1，不要尝试在遍历过程中对原数组进行任何修改【布尔类型】Array.prototype.some() 如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。【布尔类型】Array.prototype.every() 如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。Array.prototype.forEach() 为数组中的每个元素执行一次回调函数。【新数组】Array.prototype.map() 返回一个由回调函数的返回值组成的新数组。【新数组】Array.prototype.filter() 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回Array.prototype.entries() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。Array.prototype.keys() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键Array.prototype.values() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的值Array.prototype.reduce() 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值Array.prototype.reduceRight() 从右到左，同上 小技巧：并不是所有的都用console.log，数组用console.table就非常漂亮console.table(values) 思考：【数组，字符串，对象 相互转化】 // 字符串转数组 split// 数组转字符串 toString/join 字符串可以当做数组直接用查看某个位置字符","tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"npm淘宝镜像","date":"2018-11-15T13:18:51.000Z","path":"2018/11/15/npm/","text":"1.文档目的该文档用于解释说明npm淘宝镜像的使用参考网址：淘宝npm镜像、react native环境搭建、淘宝镜像说明 2.内容梳理淘宝镜像使用目的：加快访问速度使用方式及其对比： npm切换镜像源（加快访问速度）：npm config set registry https://registry.npm.taobao.org –globalnpm config set disturl https://npm.taobao.org/dist –global验证查看镜像源：npm config listnpm config get registrynpm config get disturl yarn方式[推荐]yarn安装：npm install -g yarnyarn配置镜像源：yarn config set registry https://registry.npm.taobao.org –globalyarn config set disturl https://npm.taobao.org/dist –global验证查看镜像源：yarn config listyarn config get registryyarn config get disturl cnpm方式[不推荐：安装的模块路径比较奇怪]npm install -g cnpm –registry=https://registry.npm.taobao.org 3.扩展查看npm全局安装默认路径（打开则可以看到具体安装的模块）：npm config get prefix全局安装模块：npm install -g @vue/cli或yarn global add @vue/cli全局卸载已安装模块：npm uninstall vue-cli -g或yarn global remove vue-cli","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"vue组件快速原型开发","date":"2018-11-15T12:56:20.000Z","path":"2018/11/15/vueserve/","text":"1.文档目的该文档用于快速开发vue组件，不用初始化完整的vue项目，就可以直接开发预览vue组件参考网址：基于vue cli 3.0中快速原型开发模块 2.快速原型开发检查是否安装了vue cli 3.0开发环境： vue –version安装vue cli 3.0环境: npm install -g @vue/cli或yarn global add @vue/cli安装全局扩展： npm install -g @vue/cli-service-global编写App.vue组件：123&lt;template&gt; &lt;h1&gt;Hello!&lt;/h1&gt;&lt;/template&gt; 运行组件： vue serve编译构建组件： vue build","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"keymap","date":"2018-11-15T12:12:21.000Z","path":"2018/11/15/keymap/","text":"1.windows平台常用快捷键【win系统】无鼠标快捷操作电脑[win7][1]开启键盘操作鼠标控制面板-&gt;轻松访问-&gt;鼠标更易用-&gt;设置鼠标键…Alt+Shift[左]+Num Lock启用,小键盘数字键控制方向,5确认单击,Shift+数字减速移动,Ctrl加速移动[2]常用系统快捷键WIN 打开搜素程序和文件WIN+E 我的电脑WIN+T 切换任务栏WIN+L 锁定计算机WIN+D 显示桌面WIN+M 最小化所有窗口WIN+R 打开运行对话框WIN+Tab 3D切换任务栏程序WIN+空格键 预览桌面WIN+方向键 最大/小化窗口/左右移动窗口关闭活动应用程序:Alt+F4 【Webstorm快捷键】多处编辑：Alt+左键单击控制台：Alt+F12打开任何文件：Double Shift打开最近文件：Ctrl+E全局搜索字符串：Ctrl+HSettings:Ctrl+Alt+SFormat code:Ctrl+Alt+L删除一行： Ctrl+X复制行：Ctrl+D查找行：Ctrl+G折叠代码块： Ctrl+加减号注释：Ctrl+/ 或 Ctrl+Shift+/向上/下移动代码行：Shift+Alt+Up/Down向上/下移动代码块：Ctrl+Shift+Up/Down方法追踪：Ctrl+B或Ctrl+左键单击跳转到变量实现处：Ctrl+B跳转到方法实现处：Ctrl + Alt + B打开定义快速查看：Ctrl + Shift + I跳转到当前页面的上/下一个方法块：Alt + Up/Down高亮错误或警告快速定位：F2格式化代码：Ctrl+Alt+L自动修正：Alt+Enter查找文本：Ctrl+F查找下/上一个：F3/Shift + F3高亮显示选中文本：Ctrl+Shift+F7替换文本：Ctrl+R方法参数提示：Ctrl+P显示方法注释：Ctrl+Q打开配置窗口：Ctrl+Alt+S文件名查找文件：Ctrl+Shift+N通过字符快速查找：Ctrl+Shift+Alt+N重新开始一行（无论光标在哪里）：Shift+Entersurround with代码块：Ctrl+Alt+T大小写转换：Ctrl+Shift+U输出模板：Ctrl+J匹配代码块括号：Ctrl+[显示当前文件的结构：Ctrl+F12折叠/展开代码块：Ctrl+”-“/“+”返回至上次浏览的位置 Ctrl+Alt+ left/right逐级向上选中代码：Ctrl+W 【浏览器】打开新窗口:Ctrl+T切换导航栏窗口:Ctrl+Tab关闭活动页面:Ctrl+W上下浏览网页:方向键和Page Up和Page Down 2.mac平台常用快捷键【mac系统】Command + Shift + c 打开我的电脑Command + Shift + h 打开当前用户文件夹Command + 向上箭头 打开包含当前文件夹的文件夹Command + [ / ] 打开上一个文件夹/下一个文件夹Command + w 关闭最前tabCommand + m 最小化当前应用窗口Command + q 关闭当前应用Command + T 打开多个tab 【eg:浏览器，Terminal】Command + Tab 多窗口切换 【三个小手指向上滑，平铺当前打开窗口】control + tab 转向下一个标签页【eg:webStorm多个编辑窗口】control + shift + tab 转向上一个标签页Control + 向上向下 查看所有打开窗口【两个手指向下滑：向下滚动】 Command + shift + n 新建文件夹Command + N 新建文件【eg:sublime新文件，webStorm新文件】Command + delete 删除Return 重命名选中的文件或文件夹 Shift 搜狗输入法中英文切换Command + , 当前应用的偏好设置 【文件处理快捷键】Command + Fn + 上下左右 将光标移动到可视范围开头/结尾/文档开头/结尾Command + 左右 将光标移动到行首/行尾Command + L 将光标移动到指定行Command + shift + 上下左右 选中文本alt + 上下 选取代码块Shift + 上下左右 扩展选择区域Command + f 查找Command + r 替换Delete 删除光标左边的字符Fn + delete 删除光标右边的字符Option + delete 删除光标左边的word 【截图快捷键】Command + shift + 3 屏幕快照，拍摄整个屏幕的屏幕快照，截取全屏到文件Command + shift + 4 截取选中屏幕区域到文件Command + shift + control + 3 截取全屏到剪贴板Command + shift + control + 4 截取选中屏幕区域到剪贴板 【Mac下浏览器快捷键】Command + L 光标直接跳至地址栏Chrome 开发者模式 Command + alt + j刷新 Command + r 【Mac下webStorm快捷键】全局查找 Command + shift + f格式整理 Command + alt + L注释：Command + /调整缩进 Shift + tab复制当前行 Command + d删除当前行 Command + delete快速换行 Shift + Enter清除缩进变成单行 Command + Shift + J光标在多处定位 Alt + 单击大小写转换 Command + Shift + U 3.其他工具【sublime】sublime修炼：一款得心应手的开发软件1.sublime官网下载，安装时勾选右键打开文件2.快捷键设置Preferences-&gt;Key Bindings-User打开浏览器：ctrl+alt+f3.命令模式ctrl+shift+p，输入install package，安装命令包 【VIM】【命令模式】左下上右:HJKL向右向下跳一个词:w/b下/上一个句子/段落 （）/{}跳转到行首/行尾：0/shift+$跳转到最后一行/第一行：shift+G/gg跳转到上一次编辑的地方：跳转到上一次编辑的文件：ctrl+o/ctrl+i整行选中： 光标移动到起始点shfit+V, 然后按j/k区域选中整行非整行选中： 光标移动到起始点V, 然后按H/J/K/L区域选中整行删除选中内容:X删除某行：DD / dl (L字符) /dw (w单词)替换某行：CC (删除内容，并进入编辑模式等待输入被替换内容) /cl /cw复制当前行：YY /yl /yw复制一个词：YW复制任意选中内容：先选中，再按Y粘贴：P撤销：U/u代码格式化 选中，按= 【编辑模式】进入/退出 :i/a/0/shift+o esc自动补齐：ctrl+N 若有多个备选项继续ctrl+N选中下一项，ctrl+P选中上一项（基于本文件补全） 【扩展模式】：! 命令 （叹号后面有个空格）搜索：/searchText /搜索文本 回车确认 然后按N查找下一个向前搜索：？searchText退出搜索高亮：nohl[质疑]替换：%s/searchText/replaceText/g %代表每行，s代表全局，第一个斜线代表被替换文本，第二个代表要替换文本,g全局[质疑]多行局部替换：首先选中多行Shift+V，再Shift:s/searchText/replaceText横屏分屏：sp 上下横屏切换ctrl+ww竖屏分屏：vs 左右竖屏切换ctrl+ww退出分屏：q显示行号：set number","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"hexo使用笔记","date":"2018-11-15T11:44:41.000Z","path":"2018/11/15/hexo/","text":"1.文档目的该文档用于自己及时查看，并快速上手继续写博客参考网址：hexo官方文挡 2.快速编写博客1.查看自己远程博客：https://zhuxiaobotongxue.github.io/2.本地化启动服务：hexo s3.如何生成一篇博客(如：git1)：hexo new post git14.打开source文件夹并编辑博客，markdown语法5.编译博客： hexo g6.部署至远程：hexo d7.备份原代码：git add ./git commit -m ‘’/git push","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"开发者工具","date":"2018-06-29T12:49:28.000Z","path":"2018/06/29/googledev/","text":"1.Elementsctrl+shift+c 选取dom元素ESC 在Elements面板可以用打开Console在Elements元素面板中可以通过键盘方向键折叠和向上向下快速选择节点,同时面包屑导航会给出层级结构,按住并拖动节点可以移动节点位置,查看元素事件侦听器,选中对应元素,打开Elements-&gt;Event Listeners,进一步打开对应选择器后,在handler上单击右键选择show function definition,可以查看具体方法定义,单击节点,右键Break on可以为节点添加Dom事件监听,在Elements-&gt;DOM Breakpoints面板可以查看详情,鼠标悬停在Elements-&gt;Styles面板对应css名称上可以查看受影响的Dom,在对应css右下角有小图标可以调整颜色和阴影,编辑数字和css属性值时,可以使用键盘箭头增大缩小,也可以使用鼠标滚轮,Ctrl+点击任何css属性可以直接跳转至对应文件相应行 2.Console提供了一个命令行接口，用来与网页代码互动。F12 打开DevToolsctrl+shift+J 打开控制台并定位光标ctrl+L 清空控制台console.log(‘aaa’);console.info(‘aaa’);console.error(‘aaa’);console.warn(‘aaa’);分组日志console.group(‘aaa’);console.log(‘我是aaa小组的日志’);console.groupEnd();断言日志console.assert(false,’当第一个参数为false时输出该条消息’);统计执行次数日志function myFun(){ console.count(‘myFun被执行的次数’);}myFun();myFun();输出对象的属性和方法console.dir(document.body);统计代码执行时间console.time(“Array initialize”);var array=new Array(1000000);for(var i=array.length - 1;i&gt;=0;i–){ array[i] = new Object();};console.timeEnd(“Array initialize”);查看代码执行对cpu的使用情况console.profile(“Array initialize”);var array=new Array(1000000);for(var i=array.length - 1;i&gt;=0;i–){ array[i] = new Object();};console.profileEnd(“Array initialize”);执行完成后在Profiles面板里面查看就可以看到cpu相关使用信息复制选中的DOM结构至剪切板copy(document.body);输出对象的键或值对var myObj = {name:’xiaoming’,sex:’female’};keys(myObj);values(myObj);用表格样式输出json格式数组var myArray = [{“name”:”xiaoming”},{“sex”:”12”}];console.table(myArray); console.log(‘%c This text is styled!’, ‘color: red; background: yellow; font-size: 24px;’) var number = 11 * 9;var color = ‘red’;console.log(‘%d %s balloons’, number, color); %s 字符串%d 整数%i 整数%f 浮点数%o 对象的链接%c CSS格式字符串 debugger","tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"Git系列之命令一览","date":"2018-06-25T12:30:27.000Z","path":"2018/06/25/git6/","text":"1.配置/初始化/常规操作git –versiongit helpgit config –helpgit config –list –globalgit config –global –add user.name zhuxiaobotongxuegit initgit clonegit add .git commit –m “this is a commit”git push origin mastergit pull origin self_branchgit fetch origin master //拉取远程分支git merge self_branch //合并本地分支self_branch至当前分支git checkout . //撤销所有工作空间修改git reset HEAD a.html //撤销暂存区修改git revert //撤销指定的提交git checkout self_branch //切换分支git checkout –d self_branch //删除本地分支git log –p fileName //查看指定文件提交历史git log –oneline –decorate –graph –allgit diff –cachedgit mv oldName newName //文件改名git rm fileName //删除文件git branch –a //查看所有分支 2.非频繁实用操作git clone -b self_branch http://mall-service.git //克隆指定分支git reset –hard resetVersionHash //将工作空间强制恢复至指定提交git push -f origin currentBranch //将本地分支强制推送至远程git stash listgit stash pop stash@{0}git remote add origin https://github.com/Test.git //将本地项目与远程建立联系git push -u origin master //首次推送项目至远程，指定origin为默认git push –delete origin self_branch //删除远程分支git update-index –assume-unchanged FILENAME //已入库文件不再监听git update-index –no-assume-unchanged FILENAME //恢复已入库文件监听git gui //调出图形界面ssh-keygen -t rsa -C ”zhuxiaobotongxue@gmail.com” //生成秘钥 3.小专题探究拉取分支git pull origin self_branch:self_branch //拉取远程self_branch分支至本地self_branch分支等同于git fetch origin onlinegit checkout onlinegit merge origin/self_branch //将远程self_branch分支合并至当前分支创建本地分支并提交至远程git checkout –b self_branch //从当前分支创建本地分支并切换git push origin selft_branch //将新分支提交至远程忽略文件.gitignore //创建未入库文件忽略配置.[oa] 表示忽略以o或者a结尾的文件 ~ 表示忽略以~结尾的文件*.pyc 表示忽略以.pyc结尾的文件！test.pyc 表示虽然上面一条忽略了以.pyc结尾的文件，但是现在要求不能忽略test.pyc!test.py 同上，不忽略以！开头的！test.py文件foo/ 意思是忽略foo文件夹**/res 表示忽略顶层和任何层次的res文件夹a 表示忽略a文件","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git系列之冲突详解","date":"2018-06-14T15:52:59.000Z","path":"2018/06/14/git5/","text":"1.冲突产生的原因针对某个合并操作,HEAD仓库中被修改过的部分与工作目录中将被合并的修改部分为同一代码片段,此时git不知如何取舍,便会产生冲突. 2.演示冲突的产生从某个A状态出发，我们修改index.html和test.html，并将其保存至暂存区，此时本地代码会恢复至A点。如下图所示。我们再次修改index.html的同一代码片段，并将其提交至HEAD仓库。如下图所示。此时若要取出暂存区内容，就会产生冲突，具体表现如下图所示。【注意下图行为: index.html出现了冲突，将HEAD仓库代码和暂存区代码都合并到了工作目录，但text.txt并没有冲突，而是直接从暂存区取出至缓存区】 3.冲突解决的原理人为处理冲突，根据具体业务逻辑，判断代码的取舍，然后提交修改后的代码。 4.演示冲突的解决冲突文件中冲突区域如下图所示。我们调整冲突后，如下图所示。【注意：解决冲突只要删除冲突标识即可，具体内容根据具体业务取舍，下面我们假如只保留已经提交至HEAD仓库的内容】然后将处理后的文件加入缓存区，此时你会发现index.html会被自动添加至HEAD仓库，而text.txt还在缓存区，需要我们手动提交。如下图所示。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git系列之分支","date":"2018-06-14T14:21:52.000Z","path":"2018/06/14/git4/","text":"1.创建本地分支并推送至github从master分支上创建分支test_branch，并切换至该分支，如图（1）所示。 图（1）推送该分支至github，并查看所有分支，如图（2）所示。 图（2） 2.合并分支首先切换至master分支，将test_branch分支上所做的修改合并至master分支。推送合并后的提交至远程，如下图所示。【注意：严格操作，推送之前必须先git pull，若出现冲突，要先处理冲突】【小技巧：分支切换之前若本地工作目录有修改，不希望在切换后可见，可利用暂存区暂存】","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git系列之撤销","date":"2018-06-14T14:05:42.000Z","path":"2018/06/14/git3/","text":"1.工作流的状态要使用git进行版本控制，必须深刻理解并认识git工作流中的几个状态，如图（1）所示。 图（1）本地环境可以细分为3中状态：【功能尚未完毕之前，不用轻易提交至远程】工作区，修改文档尚未添加至版本控制暂存区，修改文档已添加至版本控制，但尚未提交至版本库版本库，修改文档提交至版本库，文档状态变化远程环境只有一种状态：远程分支，修改文档被提交至远程代码仓库【名词辨识】master/branch : 分支，master为项目默认分支，也叫主分支head : 本地当前版本库的指针，指向最新的提交origin : 默认的远程版本库名称 2.工作区撤销修改该状态尚未添加至版本控制，即尚未执行git add，此时撤销不可恢复。撤销执行命令git checkout .即可。 3.暂存区撤销修改该状态已添加至版本控制，即已执行git add，修改内容处于暂存区撤销执行命令git reset HEAD .即可，原理是用版本库内容替换缓存区内容，同时工作目录修改保留 4.版本库撤销修改该状态已添加至版本库，即已执行git commit,修改内容处于版本库。撤销命令如下：git reset –hard HEAD~1 撤销提交并删除修改git reset –soft HEAD~1 撤销提交并将修改恢复至暂存区git reset HEAD~1 撤销提交并就修改恢复至工作区 5.远程分支撤销修改思路：先回退本地版本库至指定版本库【同4】，再强制推送指定版本库内容至远程分支，如下图所示。也可以用–soft保持修改内容至暂存区，如下图所示。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git系列之本地仓库","date":"2018-06-14T13:48:30.000Z","path":"2018/06/14/git2/","text":"1.初始化本地仓库本地新建一个项目文件夹test,并在该文件夹中点击右键打开git bash,用git init命令来初始化git仓库，如图（1）所示。初始化后默认是master分支。 图（1）初始化仓库配置如图（2）所示【没有配置全局作用域的需要此步骤】 图（2）本地仓库现在什么也没有，我们可以新建一个文件README.txt，便于观察。添加修改并提交至HEAD，如何（3）所示。 图（3） 2.推送本地仓库至github先登录github官网，并创建一个空的同名项目test【注意不要勾选README.txt】。复制项目的git地址（如：git@github.com:zhuxiaobotongxue/test.git）。在git bash中执行命令如图（4）所示【注意首次提交要有-u参数】。 图（4）此时刷新github仓库，就可以看到内容提交成功了。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Git系列之环境配置与github代码托管","date":"2018-06-13T14:35:54.000Z","path":"2018/06/13/git1/","text":"1.名词解释Git: 一个免费的开源分布式版本控制系统github: 一个面向开源及私有软件项目的托管平台 2.Git下载安装与配置从git官网上下载并傻瓜式安装，安装完成后在桌面单击右键，看到“Git Bash Here”和“Git Gui Here”说明安装成功。单击打开“Git Bash Here”输入命令检查版本信息，如图（1）所示。 图（1）git基本配置如图（2）所示，前两个命令添加，第三个命令查看。更多关于配置的操作可以输入git config –help查看。图（2）配置ssh-keygen如图（3）所示，输入命令后，依次输入三个回车。然后在系统目录C:\\Users\\Administrator.ssh文件夹中会看到两个文件id_rsa和id_rsa.pub，后者中的内容将用于配置在github中，服务于代码传输。图（3） 3.github配置并新建托管项目访问github官网，没有账号的自行注册并登陆【建议注册邮箱同git配置邮箱】。在右上角个人头像处单击，并点击Settings选项，找到SSH and GPG keys,并点击右上角“New SSH key”的按钮来添加配置。Title名字可以自己命名，key的内容要复制上面生成的id_rsa.pub中的内容，确认后输入注册账号时的密码，配置好后如图（4）所示。 图（4）回到github首页，找到“New repository”按钮，新建一个项目仓库，如图（5）所示。图（5）创建完成后找到“Clone and download”按钮，点击并复制项目仓库路径，如图（6）所示。图（6）在系统中找一个合适的文件夹放置项目代码，在该文件夹中打开git bash，输入命令来下载github上新创建的项目代码，首次输入命令后可能会提示确认操作，此时输入yes即可，下载完成后，如图（7）所示。此时项目已被下载到了文件夹中。图（7）","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]}]