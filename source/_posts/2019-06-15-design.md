---
title: 设计模式解读
date: 2019-06-15 15:35:34
tags: JS
---
## 1.文档目的
系统记录常见设计模式的js代码实现，加深理解设计模式的魅力。
参考网址：[w3c设计模式](https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-ljp4285i.html)

## 2.设计模式一览
**构造函数模式**：模拟类，用于创建特定类型（类）的对象
**单例模式**：在某空间提供唯一的访问点，保证一个类只有一个实例
**工厂模式**：定义一个用于创建对象的接口，由子类决定实例化哪个类（厂长负责实施子类发出的任务）
**代理模式**：为其他对象提供一种代理以控制对这个对象的访问（eg：大叔代替小明送给女孩儿鲜花）
**建造者模式**：使同样的构建过程（eg:回调机制）可以创建不同的表示（由参数决定），而不用关注细节（回调的实现原理）
**命令模式**：用于将一个请求方法封装成一个对象（参数不同，命令不同）
**观察者模式**：发布订阅模式
**适配器模式**：将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（比如：电脑充电器）
**职责链模式**：使多个对象都有机会处理请求
**迭代器模式**：为遍历不同的集合结构提供一个统一的接口
**外观模式**：为一组接口提供一个高层接口，使得接口更容易使用。比如根据不同浏览器触发事件的封装
**策略模式**：算法的相互替换不会影响到使用算法的客户
**中介者模式**：比如多架飞机的通讯都是通过中控系统进行
**原型模式**：通过拷贝原型创建新对象，比如js里的prototype
**模板方法**：定义操作的算法的骨架（抽象类），而将步骤实现延迟到子类中（子类重写父类方法）
**装饰者模式**：包装同接口的对象，通过重载方法的形式添加新功能（调用原始对象方法并扩展）
**组合模式**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。（eg:Dom都有增删改子节点的通用功能）

## 3.实例研读
### 3.1构造函数模式
```
// 构造函数模式：用于创建特定类型（类）的对象[可接收参数以便第一次创建对象时设置成员值]
// 注：这里将属性和方法都写在构造函数中，那么每个新的实例都会不同，若需共享，应绑定至prototype
function Car(model, year, miles) {
    this.model = model;
    this.year = year;
    this.miles = miles;
}

//注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype
//主要是用来避免重写定义原型prototype对象

Car.prototype.output= function () {
    return this.model + "走了" + this.miles + "公里";
};

var tom = new Car("大叔", 2009, 20000);
var dudu = new Car("Dudu", 2010, 5000);

console.log(tom.output());
console.log(dudu.output());
```
### 3.2单例模式
```
//单例模式：保证一个类只有一个实例
//实现的方法是先判断实例是否存在，若存在则直接返回，否则再创建
//用途：单例作为命名空间提供者，保证在某空间中提供一个唯一的访问点
var SingletonTester = (function () {

    //参数：传递给单例的一个参数集合
    function Singleton(args) {

        //设置args变量为接收的参数或者为空（如果没有提供的话）
        var args = args || {};
        //设置name参数
        this.name = 'SingletonTester';
        //设置pointX的值
        this.pointX = args.pointX || 6; //从接收的参数里获取，或者设置为默认值
        //设置pointY的值
        this.pointY = args.pointY || 10;

    }

    //实例容器
    var instance;

    var _static = {
        name: 'SingletonTester',

        //获取实例的方法
        //返回Singleton的实例
        getInstance: function (args) {
            if (instance === undefined) {
                instance = new Singleton(args);
            }
            return instance;
        }
    };
    return _static;
})();

var singletonTest = SingletonTester.getInstance({ pointX: 5 });
console.log(singletonTest.pointX); // 输出 5 
```
### 3.3工厂模式
```
//工厂模式定义了一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。
//该模式使一个类的实例化延迟到了子类。
//工程模式应该有厂长，负责调度实施子类发出的任务
var productManager = {};

productManager.createProductA = function () {
    console.log('ProductA');
}

productManager.createProductB = function () {
    console.log('ProductB');
}

productManager.factory = function (typeType) {
    return new productManager[typeType];
}

productManager.factory("createProductA");
```
