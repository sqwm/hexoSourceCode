---
title: 设计模式解读
date: 2019-06-15 15:35:34
tags: JS
---
## 1.文档目的
系统记录常见设计模式的js代码实现，加深理解设计模式的魅力。
参考网址：[w3c设计模式](https://www.w3cschool.cn/deep_learn_javascript/deep_learn_javascript-ljp4285i.html)

## 2.设计原则
**单一职责原则SRP**: 属性及其相关操作
**开闭原则OCP**: 对扩展开放,对修改关闭
**里氏替换原则LSP**: 怎么理解好呢

## 3.设计模式一览
**构造函数模式**：模拟类，用于创建特定类型（类）的对象
**原型模式**：通过拷贝原型创建新对象，比如js里的prototype
**单例模式**：在某空间提供唯一的访问点，保证一个类只有一个实例
**工厂模式**：定义一个用于创建对象的接口，由子类决定实例化哪个类（厂长负责实施子类发出的任务）
**桥接模式**: 若不希望两个层次之间耦合，桥接模式可以使它们建立一个关联关系
**代理模式**：为其他对象提供一种代理以控制对这个对象的访问（eg：大叔代替小明送给女孩儿鲜花）
**建造者模式**：使同样的构建过程（eg:回调机制）可以创建不同的表示（由参数决定），而不用关注细节（回调的实现原理）
**命令模式**：用于将一个请求方法封装成一个对象（参数不同，命令不同）
**观察者模式**：发布订阅模式
**适配器模式**：将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（比如：电脑充电器）
**职责链模式**：使多个对象都有机会处理请求
**迭代器模式**：为遍历不同的集合结构提供一个统一的接口
**外观模式**：为一组接口提供一个高层接口，使得接口更容易使用
**策略模式**：算法的相互替换不会影响到使用算法的客户
**中介者模式**：比如多架飞机的通讯都是通过中控系统进行
**模板方法**：定义操作的算法的骨架（抽象类），而将步骤实现延迟到子类中（子类重写父类方法）
**装饰者模式**：包装同接口的对象，通过重载方法的形式添加新功能（调用原始对象方法并扩展）
**组合模式**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。（eg:Dom都有增删改子节点的通用功能）
**模板方法**:定义一个操作中的算法的骨架，而将一些步骤延迟到子类重写

## 3.实例研读
### 3.1构造函数模式
构造函数模式：用于创建特定类型（类）的对象[可接收参数以便第一次创建对象时设置成员值]
```
// 注：这里将属性和方法都写在构造函数中，那么每个新的实例都会不同，若需共享，应绑定至prototype
function Animal(name) {
    this.name = name;
}
//注意：这里我们使用了Object.prototype.方法名，而不是Object.prototype
//主要是用来避免重写定义原型prototype对象
Animal.prototype.getName= function () {
    return '该动物的名称' + this.name
};
var animal = new Animal("老虎");
console.log(animal.getName());
```
### 3.2原型模式
通过拷贝原型创建新对象[在上面构造函数的基础上利用原型模式实现继承]
```
function Cat(){}
// 拷贝继承
Cat.prototype = Animal.prototype;
// 恢复constructor
Cat.prototype.constructor = Cat;
// 实例化
var cat = new Cat("花小猫");
console.log(cat.getName()) // 花小猫
```
### 3.3单例模式
单例模式：保证一个类只有一个实例
实现的方法是先判断实例是否存在，若存在则直接返回，否则再创建
用途：单例作为命名空间提供者，保证在某空间中提供一个唯一的访问点
```
var SingletonTester = (function () {
    //参数：传递给单例的一个参数集合
    function Singleton(args) {
        //设置args变量为接收的参数或者为空（如果没有提供的话）
        var args = args || {};
        //设置name参数
        this.name = 'SingletonTester';
        //设置pointX的值
        this.pointX = args.pointX || 6; //从接收的参数里获取，或者设置为默认值
        //设置pointY的值
        this.pointY = args.pointY || 10;
    }
    //实例容器
    var instance;
    var _static = {
        name: 'SingletonTester',
        //获取实例的方法
        //返回Singleton的实例
        getInstance: function (args) {
            if (instance === undefined) {
                instance = new Singleton(args);
            }
            return instance;
        }
    };
    return _static;
})();
var singletonTest = SingletonTester.getInstance({ pointX: 5 });
console.log(singletonTest.pointX); // 输出 5 
```
### 3.3工厂模式
工厂模式定义了一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。
该模式使一个类的实例化延迟到了子类。
工程模式应该有厂长，负责调度实施子类发出的任务
eg:switch动态匹配就是该模式
```
// 对象方式
var productManager = {};
productManager.createProductA = function () {
    console.log('ProductA');
}
productManager.createProductB = function () {
    console.log('ProductB');
}
productManager.factory = function (typeType) {
    return new productManager[typeType];
}
productManager.factory("createProductA");
// 方法方式
function switchFun(type){
  switch(type){
    case 'ProductA':
      console.log('ProductA')
      break
    case 'ProductB':
      console.log('ProductB')
      break
    default:
      console.log('nothing')
  }
}
switchFun("ProductA");
```
### 3.4桥接模式
若不希望两个层次之间耦合，桥接模式可以使它们建立一个关联关系。
eg:接口返回的数据属性 与 前端逻辑使用的字段属性,不希望两者耦合,可通过transData()桥接转换属性
```
transData(data){
	let {userName1: name, userAge1: age} = data
	let oInfo = {name, age}
	return oInfo
}
```
### 3.5外观模式
如果需要调用一组接口实现一个更大的功能,那么就把这些方法放在一起组成一个新的方法,从而简化调用
eg:阻止事件默认行为
```
function handleClick(e) {
    e.preventDefault();
    e.stopPropagation();
}
```
### 3.6模板方法
定义一个操作中的算法的骨架，而将一些步骤延迟到子类重写
```
<script>
    // 抽象步骤
    var MakeDrink = function() {}
    MakeDrink.prototype.step = function() {
      this.boilWater()
      this.addDrink()
      this.cover()
    }
    MakeDrink.prototype.boilWater = function() {
      console.log('将水烧开!')
    }
    MakeDrink.prototype.addDrink = function() {
      throw new Error('该方法必须重写!')
    }
    MakeDrink.prototype.cover = function() {
      console.log('盖上盖子!')
    }

    // 冲咖啡
    var Coffee = function() {
      MakeDrink.apply(this)
    }
    Coffee.prototype = new MakeDrink()
    Coffee.prototype.addDrink = function() {
      console.log('添加咖啡!')
    }

    //冲茶叶
    var Tea = function() {
      MakeDrink.apply(this)
    }
    Tea.prototype = new MakeDrink()
    Tea.prototype.addDrink = function() {
      console.log('添加茶叶!')
    }

    // 验证调用
    var coffee1 = new Coffee()
    coffee1.step()
    console.log('--------分割线----------')
    var tea1 = new Tea()
    tea1.step()
  </script>
```
### 3.7策略模式
校验表单
```
<script>
  // 策略处理类
  let validator = {
    types: {}, // 验证规则处理类,后面会扩展各种规则的定义
    config: {}, // 定义需要使用的验证类型
    messages: [], // 验证所对应的错误消息集合
    validate: function(data) {
      // 暴露的公开验证方法,参数类型为obj,data是原始数据
      let msg, type, validateTypeFun, result_ok
      this.messages = [] // 清空所有的错误信息
      for (let key in data) {
        if (data.hasOwnProperty(key)) { //原始数据中是否包含可枚举的字段key
          type = this.config[key] // 用户为字段key配置的验证规则是什么?比如isNonEmpty
          validateTypeFun = this.types[type] // 获取验证规则对应的验证方法是否已定义
          if (!type) {
            continue // 如果针对key的验证规则未配置，则不处理
          }
          if (!validateTypeFun) { // 如果验证方法为定义，抛出异常
            throw {
              name: 'ValidationError',
              message: '该类型无对应处理方法:' + type
            }
          }
          result_ok = validateTypeFun.validate(data[key]) //正常验证
          if (!result_ok) {
            msg = '非法值' + key + ', ' + validateTypeFun.instructions
            this.messages.push(msg)
          }
        }
      }
      return this.hasErrors()
    },

    // helper
    hasErrors: function() {
      return this.messages.length !== 0
    }
  }

  // 验证给定的值是否不为空
  validator.types.isNotEmpty = {
    validate: function(value) {
      return value !== ''
    },
    instructions: '传入的值不能为空'
  }
  // 验证给定的值是否是数字
  validator.types.isNumber = {
    validate: function(value) {
      return !isNaN(value)
    },
    instructions: '传入的值只能是合法的数字，例如：1, 3.14 or 2010'
  }

  // 定义需要验证的数据集合和需要验证的规则类型
  var data = {
    first_name: '',
    age: 'unknown'
  }
  validator.config = {
    first_name: 'isNotEmpty',
    age: 'isNumber'
  }

  // 测试获取验证结果
  validator.validate(data)
  if (validator.hasErrors()) {
    console.log(validator.messages.join('\n'))
  }
</script>
```
